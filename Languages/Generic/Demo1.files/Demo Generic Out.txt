
^)^: ` 10 REM INSTRUCTIONS FOR "SUPER STARTREK"  MAR 5, 1978`GoToNextLine ^(^

^)^: ` 10 REM INSTRUCTIONS FOR "SUPER STARTREK"  MAR 5, 1978`GoToNextLine ^(^

^)^: ` 20 FOR I=1 TO 12:PRINT:NEXT I`GoToNextLine ^(^

^)^: ` 20 FOR I=1 TO 12:PRINT:NEXT I`GoToNextLine ^(^

^)^: ` 25 PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 25 PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 30 PRINT TAB(10);"*************************************"`GoToNextLine ^(^

^)^: ` 30 PRINT TAB(10);"*************************************"`GoToNextLine ^(^

^)^: ` 40 PRINT TAB(10);"*                                   *"`GoToNextLine ^(^

^)^: ` 40 PRINT TAB(10);"*                                   *"`GoToNextLine ^(^

^)^: ` 40 PRINT TAB(10);"*                                   *"`GoToNextLine ^(^

^)^: ` 60 PRINT TAB(10);"*      * * SUPER STAR TREK * *      *"`GoToNextLine ^(^

^)^: ` 60 PRINT TAB(10);"*      * * SUPER STAR TREK * *      *"`GoToNextLine ^(^

^)^: ` 40 PRINT TAB(10);"*                                   *"`GoToNextLine ^(^

^)^: ` 40 PRINT TAB(10);"*                                   *"`GoToNextLine ^(^

^)^: ` 30 PRINT TAB(10);"*************************************"`GoToNextLine ^(^

^)^: ` 20 FOR I=1 TO 12:PRINT:NEXT I`GoToNextLine ^(^

^)^: ` 110 INPUT "DO YOU NEED INSTRUCTIONS (Y/N)";K$:IF K$="N" THEN 1210`GoToNextLine ^(^

^)^: ` 110 INPUT "DO YOU NEED INSTRUCTIONS (Y/N)";K$:IF K$="N" THEN 1210`GoToNextLine ^(^

^)^: ` 25 PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 352 LINE INPUT "ENTER [CR] TO CONTINUE";A$:IF A$="" THEN PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 352 LINE INPUT "ENTER [CR] TO CONTINUE";A$:IF A$="" THEN PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 530 PRINT:PRINT`GoToNextLine ^(^

^)^: ` 530 PRINT:PRINT`GoToNextLine ^(^

^)^: ` 352 LINE INPUT "ENTER [CR] TO CONTINUE";A$:IF A$="" THEN PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 530 PRINT:PRINT`GoToNextLine ^(^

^)^: ` 352 LINE INPUT "ENTER [CR] TO CONTINUE";A$:IF A$="" THEN PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 352 LINE INPUT "ENTER [CR] TO CONTINUE";A$:IF A$="" THEN PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 530 PRINT:PRINT`GoToNextLine ^(^

^)^: ` 352 LINE INPUT "ENTER [CR] TO CONTINUE";A$:IF A$="" THEN PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 1210 PRINT:PRINT:PRINT`GoToNextLine ^(^

^)^: ` 1210 PRINT:PRINT:PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 1230 LOAD "STARTREK.BAS",R`GoToNextLine ^(^

^)^: ` 1230 LOAD "STARTREK.BAS",R`GoToNextLine ^(^

^)^: ` 1240 END`GoToNextLine ^(^

^)^: ` 1240 END`GoToNextLine ^(^

^)^: ` 10 REM SUPER STARTREK - MAY 16,1978 - REQUIRES 24K MEMORY (AT LEAST)`GoToNextLine ^(^

^)^: ` 10 REM SUPER STARTREK - MAY 16,1978 - REQUIRES 24K MEMORY (AT LEAST)`GoToNextLine ^(^

^)^: ` 30 REM`GoToNextLine ^(^

^)^: ` 30 REM`GoToNextLine ^(^

^)^: ` 40 REM ****        **** STAR TREK ****      ****`GoToNextLine ^(^

^)^: ` 40 REM ****        **** STAR TREK ****      ****`GoToNextLine ^(^

^)^: ` 50 REM **** SIMULATION OF A MISSION OF THE STARSHIP ENTERPRISE,`GoToNextLine ^(^

^)^: ` 50 REM **** SIMULATION OF A MISSION OF THE STARSHIP ENTERPRISE,`GoToNextLine ^(^

^)^: ` 60 REM **** AS SEEN ON THE STAR TREK TV SHOW.`GoToNextLine ^(^

^)^: ` 60 REM **** AS SEEN ON THE STAR TREK TV SHOW.`GoToNextLine ^(^

^)^: ` 70 REM **** ORIGINAL PROGRAM BY MIKE MAYFIELD, MODIFIED VERSION`GoToNextLine ^(^

^)^: ` 70 REM **** ORIGINAL PROGRAM BY MIKE MAYFIELD, MODIFIED VERSION`GoToNextLine ^(^

^)^: ` 80 REM **** PUBLISHED IN DEC'S "101 BASIC GAMES", BY DAVE AHL.`GoToNextLine ^(^

^)^: ` 80 REM **** PUBLISHED IN DEC'S "101 BASIC GAMES", BY DAVE AHL.`GoToNextLine ^(^

^)^: ` 90 REM **** MODIFICATIONS TO THE LATTER (PLUS DEBUGGING) BY BOB`GoToNextLine ^(^

^)^: ` 90 REM **** MODIFICATIONS TO THE LATTER (PLUS DEBUGGING) BY BOB`GoToNextLine ^(^

^)^: ` 100 REM *** LEEDOM - APRIL & DECEMBER 1974,`GoToNextLine ^(^

^)^: ` 100 REM *** LEEDOM - APRIL & DECEMBER 1974,`GoToNextLine ^(^

^)^: ` 110 REM *** WITH A LITTLE HELP FROM HIS FRIENDS . . .`GoToNextLine ^(^

^)^: ` 110 REM *** WITH A LITTLE HELP FROM HIS FRIENDS . . .`GoToNextLine ^(^

^)^: ` 120 REM *** COMMENTS, EPHITETS, AND SUGGESTIONS SOLICITED --`GoToNextLine ^(^

^)^: ` 120 REM *** COMMENTS, EPHITETS, AND SUGGESTIONS SOLICITED --`GoToNextLine ^(^

^)^: ` 130 REM *** SEND TO: R.C. LEEDOM`GoToNextLine ^(^

^)^: ` 130 REM *** SEND TO: R.C. LEEDOM`GoToNextLine ^(^

^)^: ` 140 REM ***          WESTINGHOSE DEFENSE & ELECTRONICS SYSTEMS CNIR`GoToNextLine ^(^

^)^: ` 140 REM ***          WESTINGHOSE DEFENSE & ELECTRONICS SYSTEMS CNIR`GoToNextLine ^(^

^)^: ` 150 REM ***          BOX 746, M.S. 338`GoToNextLine ^(^

^)^: ` 150 REM ***          BOX 746, M.S. 338`GoToNextLine ^(^

^)^: ` 160 REM ***          BALTIMORE, MD 21203`GoToNextLine ^(^

^)^: ` 160 REM ***          BALTIMORE, MD 21203`GoToNextLine ^(^

^)^: ` 170 REM ***`GoToNextLine ^(^

^)^: ` 170 REM ***`GoToNextLine ^(^

^)^: ` 180 REM *** CONVERTED TO MICROSOFT 8 K BASIC 3/16/78 BY JOHN BORDERS`GoToNextLine ^(^

^)^: ` 180 REM *** CONVERTED TO MICROSOFT 8 K BASIC 3/16/78 BY JOHN BORDERS`GoToNextLine ^(^

^)^: ` 190 REM *** LINE NUMBERS FROm VERSION TREK7 OF 1/12/75 PRESERVED AS`GoToNextLine ^(^

^)^: ` 190 REM *** LINE NUMBERS FROm VERSION TREK7 OF 1/12/75 PRESERVED AS`GoToNextLine ^(^

^)^: ` 200 REM *** MUCH AS POSSIBLE WHILE USING MULTIPLE STATEMENTS PER LINE`GoToNextLine ^(^

^)^: ` 200 REM *** MUCH AS POSSIBLE WHILE USING MULTIPLE STATEMENTS PER LINE`GoToNextLine ^(^

^)^: ` 205 WIDTH 80`GoToNextLine ^(^

^)^: ` 205 WIDTH 80`GoToNextLine ^(^

^)^: ` 25 PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 220 FOR XX=1 TO 6:PRINT:NEXT:PRINT TAB(20);"THE USS ENTERPRISE --- NCC-1701":PRINT:FOR YY=1 TO 40 STEP 2`GoToNextLine ^(^

^)^: ` 220 FOR XX=1 TO 6:PRINT:NEXT:PRINT TAB(20);"THE USS ENTERPRISE --- NCC-1701":PRINT:FOR YY=1 TO 40 STEP 2`GoToNextLine ^(^

^)^: ` 221 PRINT TAB(YY);"                  ,------*------,"`GoToNextLine ^(^

^)^: ` 221 PRINT TAB(YY);"                  ,------*------,"`GoToNextLine ^(^

^)^: ` 222 PRINT TAB(YY);"  ,-------------   '---  ------'"`GoToNextLine ^(^

^)^: ` 222 PRINT TAB(YY);"  ,-------------   '---  ------'"`GoToNextLine ^(^

^)^: ` 223 PRINT TAB(YY);"   '-------- --'      / /"`GoToNextLine ^(^

^)^: ` 223 PRINT TAB(YY);"   '-------- --'      / /"`GoToNextLine ^(^

^)^: ` 224 PRINT TAB(YY);"       ,---' '-------/ /--,"`GoToNextLine ^(^

^)^: ` 224 PRINT TAB(YY);"       ,---' '-------/ /--,"`GoToNextLine ^(^

^)^: ` 225 PRINT TAB(YY);"        '----------------'"`GoToNextLine ^(^

^)^: ` 225 PRINT TAB(YY);"        '----------------'"`GoToNextLine ^(^

^)^: ` 226 PRINT:PRINT:FOR ZZ=1 TO 7:PRINT CHR$(11);:NEXT ZZ:NEXT YY`GoToNextLine ^(^

^)^: ` 226 PRINT:PRINT:FOR ZZ=1 TO 7:PRINT CHR$(11);:NEXT ZZ:NEXT YY`GoToNextLine ^(^

^)^: ` 227 PRINT:PRINT:PRINT:PRINT:PRINT`GoToNextLine ^(^

^)^: ` 227 PRINT:PRINT:PRINT:PRINT:PRINT`GoToNextLine ^(^

^)^: ` 260 CLEAR 600`GoToNextLine ^(^

^)^: ` 260 CLEAR 600`GoToNextLine ^(^

^)^: ` 270 Z$="                         "`GoToNextLine ^(^

^)^: ` 270 Z$="                         "`GoToNextLine ^(^

^)^: ` 330 DIM G(8,8),C(9,2),K(3,3),N(3),Z(8,8),D(8)`GoToNextLine ^(^

^)^: ` 330 DIM G(8,8),C(9,2),K(3,3),N(3),Z(8,8),D(8)`GoToNextLine ^(^

^)^: ` 370 T=INT(RND(1)*20+20)*100:T0=T:T9=25+INT(RND(1)*10):D0=0:E=3000:E0=E`GoToNextLine ^(^

^)^: ` 370 T=INT(RND(1)*20+20)*100:T0=T:T9=25+INT(RND(1)*10):D0=0:E=3000:E0=E`GoToNextLine ^(^

^)^: ` 440 P=10:P0=P:S9=200:S=0:B9=0:K9=0:X$="":X0$=" IS "`GoToNextLine ^(^

^)^: ` 440 P=10:P0=P:S9=200:S=0:B9=0:K9=0:X$="":X0$=" IS "`GoToNextLine ^(^

^)^: ` 470 DEF FND(D)=SQR((K(I,1)-S1)^2+(K(I,2)-S2)^2)`GoToNextLine ^(^

^)^: ` 470 DEF FND(D)=SQR((K(I,1)-S1)^2+(K(I,2)-S2)^2)`GoToNextLine ^(^

^)^: ` 475 DEF FNR(R)=INT(RND(R)*7.98+1.01)`GoToNextLine ^(^

^)^: ` 475 DEF FNR(R)=INT(RND(R)*7.98+1.01)`GoToNextLine ^(^

^)^: ` 490 Q1=FNR(1):Q2=FNR(1):S1=FNR(1):S2=FNR(1)`GoToNextLine ^(^

^)^: ` 490 Q1=FNR(1):Q2=FNR(1):S1=FNR(1):S2=FNR(1)`GoToNextLine ^(^

^)^: ` 530 FOR I=1 TO 9:C(I,1)=0:C(I,2)=0:NEXT I`GoToNextLine ^(^

^)^: ` 530 FOR I=1 TO 9:C(I,1)=0:C(I,2)=0:NEXT I`GoToNextLine ^(^

^)^: ` 540 C(3,1)=-1:C(2,1)=-1:C(4,1)=-1:C(4,2)=-1:C(5,2)=-1:C(6,2)=-1`GoToNextLine ^(^

^)^: ` 540 C(3,1)=-1:C(2,1)=-1:C(4,1)=-1:C(4,2)=-1:C(5,2)=-1:C(6,2)=-1`GoToNextLine ^(^

^)^: ` 600 C(1,2)=1:C(2,2)=1:C(6,1)=1:C(7,1)=1:C(8,1)=1:C(8,2)=1:C(9,2)=1`GoToNextLine ^(^

^)^: ` 600 C(1,2)=1:C(2,2)=1:C(6,1)=1:C(7,1)=1:C(8,1)=1:C(8,2)=1:C(9,2)=1`GoToNextLine ^(^

^)^: ` 670 FOR I=1 TO 8:D(I)=0:NEXT I`GoToNextLine ^(^

^)^: ` 670 FOR I=1 TO 8:D(I)=0:NEXT I`GoToNextLine ^(^

^)^: ` 270 Z$="                         "`GoToNextLine ^(^

^)^: ` 820 FOR I=1 TO 8:FOR J=1 TO 8:K3=0:Z(I,J)=0:R1=RND(1)`GoToNextLine ^(^

^)^: ` 820 FOR I=1 TO 8:FOR J=1 TO 8:K3=0:Z(I,J)=0:R1=RND(1)`GoToNextLine ^(^

^)^: ` 850 IF R1>.98 THEN K3=3:K9=K9+3:GOTO 980`GoToNextLine ^(^

^)^: ` 850 IF R1>.98 THEN K3=3:K9=K9+3:GOTO 980`GoToNextLine ^(^

^)^: ` 860 IF R1>.95 THEN K3=2:K9=K9+2:GOTO 980`GoToNextLine ^(^

^)^: ` 860 IF R1>.95 THEN K3=2:K9=K9+2:GOTO 980`GoToNextLine ^(^

^)^: ` 870 IF R1>.8 THEN K3=1:K9=K9+1`GoToNextLine ^(^

^)^: ` 870 IF R1>.8 THEN K3=1:K9=K9+1`GoToNextLine ^(^

^)^: ` 980 B3=0:IF RND(1)>.96 THEN B3=1:B9=B9+1`GoToNextLine ^(^

^)^: ` 980 B3=0:IF RND(1)>.96 THEN B3=1:B9=B9+1`GoToNextLine ^(^

^)^: ` 1040 G(I,J)=K3*100+B3*10+FNR(1):NEXT J:NEXT I:IF K9>T9 THEN T9=K9+1`GoToNextLine ^(^

^)^: ` 1040 G(I,J)=K3*100+B3*10+FNR(1):NEXT J:NEXT I:IF K9>T9 THEN T9=K9+1`GoToNextLine ^(^

^)^: ` 1100 IF B9<>0 THEN 1200`GoToNextLine ^(^

^)^: ` 1100 IF B9<>0 THEN 1200`GoToNextLine ^(^

^)^: ` 1150 IF G(Q1,Q2)<200 THEN G(Q1,Q2)=G(Q1,Q2)+100:K9=K9+1`GoToNextLine ^(^

^)^: ` 1150 IF G(Q1,Q2)<200 THEN G(Q1,Q2)=G(Q1,Q2)+100:K9=K9+1`GoToNextLine ^(^

^)^: ` 1160 B9=1:G(Q1,Q2)=G(Q1,Q2)+10:Q1=FNR(1):Q2=FNR(1)`GoToNextLine ^(^

^)^: ` 1160 B9=1:G(Q1,Q2)=G(Q1,Q2)+10:Q1=FNR(1):Q2=FNR(1)`GoToNextLine ^(^

^)^: ` 1200 K7=K9:IF B9<>1 THEN X$="S":X0$=" ARE "`GoToNextLine ^(^

^)^: ` 1200 K7=K9:IF B9<>1 THEN X$="S":X0$=" ARE "`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 1240 PRINT"   DESTROY THE";K9;"KLINGON WARSHIPS WHICH HAVE INVADED"`GoToNextLine ^(^

^)^: ` 1240 PRINT"   DESTROY THE";K9;"KLINGON WARSHIPS WHICH HAVE INVADED"`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 1260 PRINT"   ON STARDATE";T0+T9;CHR$(8);". THIS GIVES YOU";T9;"DAYS. THERE";X0$`GoToNextLine ^(^

^)^: ` 1260 PRINT"   ON STARDATE";T0+T9;CHR$(8);". THIS GIVES YOU";T9;"DAYS. THERE";X0$`GoToNextLine ^(^

^)^: ` 1270 PRINT"  ";B9;"STARBASE";X$;" IN THE GALAXY FOR RESUPPLYING YOUR SHIP."`GoToNextLine ^(^

^)^: ` 1270 PRINT"  ";B9;"STARBASE";X$;" IN THE GALAXY FOR RESUPPLYING YOUR SHIP."`GoToNextLine ^(^

^)^: ` 1280 PRINT:PRINT "ARE YOU READY TO ACCEPT COMMAND ('N' FOR INSTRUCTIONS)";`GoToNextLine ^(^

^)^: ` 1280 PRINT:PRINT "ARE YOU READY TO ACCEPT COMMAND ('N' FOR INSTRUCTIONS)";`GoToNextLine ^(^

^)^: ` 1300 INPUT I5$:IF LEFT$(I5$,1)="N" OR LEFT$(I5$,1)="n" THEN RUN "TREKINST" ELSE IF LEFT$(I5$,1)="Y" OR LEFT$(I5$,1)="y" THEN 1310 ELSE 1280`GoToNextLine ^(^

^)^: ` 1300 INPUT I5$:IF LEFT$(I5$,1)="N" OR LEFT$(I5$,1)="n" THEN RUN "TREKINST" ELSE IF LEFT$(I5$,1)="Y" OR LEFT$(I5$,1)="y" THEN 1310 ELSE 1280`GoToNextLine ^(^

^)^: ` 25 PRINT CHR$(26)`GoToNextLine ^(^

^)^: ` 1320 Z4=Q1:Z5=Q2:K3=0:B3=0:S3=0:G5=0:D4=.5*RND(1):Z(Q1,Q2)=G(Q1,Q2)`GoToNextLine ^(^

^)^: ` 1320 Z4=Q1:Z5=Q2:K3=0:B3=0:S3=0:G5=0:D4=.5*RND(1):Z(Q1,Q2)=G(Q1,Q2)`GoToNextLine ^(^

^)^: ` 1390 IF Q1<1 OR Q1>8 OR Q2<1 OR Q2>8 THEN 1600`GoToNextLine ^(^

^)^: ` 1390 IF Q1<1 OR Q1>8 OR Q2<1 OR Q2>8 THEN 1600`GoToNextLine ^(^

^)^: ` 1430 GOSUB 9030:PRINT:IF T0<>T THEN 1490`GoToNextLine ^(^

^)^: ` 1430 GOSUB 9030:PRINT:IF T0<>T THEN 1490`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 1470 PRINT"IN THE GALACTIC QUADRANT, '";G2$;"'.":GOTO 1500`GoToNextLine ^(^

^)^: ` 1470 PRINT"IN THE GALACTIC QUADRANT, '";G2$;"'.":GOTO 1500`GoToNextLine ^(^

^)^: ` 1490 PRINT"NOW ENTERING ";G2$;" QUADRANT . . ."`GoToNextLine ^(^

^)^: ` 1490 PRINT"NOW ENTERING ";G2$;" QUADRANT . . ."`GoToNextLine ^(^

^)^: ` 1500 PRINT:K3=INT(G(Q1,Q2)*.01):B3=INT(G(Q1,Q2)*.1)-10*K3`GoToNextLine ^(^

^)^: ` 1500 PRINT:K3=INT(G(Q1,Q2)*.01):B3=INT(G(Q1,Q2)*.1)-10*K3`GoToNextLine ^(^

^)^: ` 1540 S3=G(Q1,Q2)-100*K3-10*B3:IF K3=0 THEN 1590`GoToNextLine ^(^

^)^: ` 1540 S3=G(Q1,Q2)-100*K3-10*B3:IF K3=0 THEN 1590`GoToNextLine ^(^

^)^: ` 1560 PRINT TAB(3);CHR$(22);"  COMBAT AREA      CONDITION RED  ";CHR$(22):IF S>200 THEN PRINT:GOTO 1590`GoToNextLine ^(^

^)^: ` 1560 PRINT TAB(3);CHR$(22);"  COMBAT AREA      CONDITION RED  ";CHR$(22):IF S>200 THEN PRINT:GOTO 1590`GoToNextLine ^(^

^)^: ` 1580 PRINT TAB(3);CHR$(22);"      SHIELDS DANGEROUSLY LOW     ";CHR$(22):PRINT`GoToNextLine ^(^

^)^: ` 1580 PRINT TAB(3);CHR$(22);"      SHIELDS DANGEROUSLY LOW     ";CHR$(22):PRINT`GoToNextLine ^(^

^)^: ` 1590 FOR I=1 TO 3:K(I,1)=0:K(I,2)=0:NEXT I`GoToNextLine ^(^

^)^: ` 1590 FOR I=1 TO 3:K(I,1)=0:K(I,2)=0:NEXT I`GoToNextLine ^(^

^)^: ` 1600 FOR I=1 TO 3:K(I,3)=0:NEXT I:Q$=Z$+Z$+Z$+Z$+Z$+Z$+Z$+LEFT$(Z$,17)`GoToNextLine ^(^

^)^: ` 1600 FOR I=1 TO 3:K(I,3)=0:NEXT I:Q$=Z$+Z$+Z$+Z$+Z$+Z$+Z$+LEFT$(Z$,17)`GoToNextLine ^(^

^)^: ` 1680 A$="<E>":Z1=S1:Z2=S2:GOSUB 8670:IF K3<1 THEN 1820`GoToNextLine ^(^

^)^: ` 1680 A$="<E>":Z1=S1:Z2=S2:GOSUB 8670:IF K3<1 THEN 1820`GoToNextLine ^(^

^)^: ` 1720 FOR I=1 TO K3:GOSUB 8590:A$="+K+":Z1=R1:Z2=R2`GoToNextLine ^(^

^)^: ` 1720 FOR I=1 TO K3:GOSUB 8590:A$="+K+":Z1=R1:Z2=R2`GoToNextLine ^(^

^)^: ` 1780 GOSUB 8670:K(I,1)=R1:K(I,2)=R2:K(I,3)=S9*(.5+RND(1)):NEXT I`GoToNextLine ^(^

^)^: ` 1780 GOSUB 8670:K(I,1)=R1:K(I,2)=R2:K(I,3)=S9*(.5+RND(1)):NEXT I`GoToNextLine ^(^

^)^: ` 1820 IF B3<1 THEN 1910`GoToNextLine ^(^

^)^: ` 1820 IF B3<1 THEN 1910`GoToNextLine ^(^

^)^: ` 1880 GOSUB 8590:A$=">B<":Z1=R1:B4=R1:Z2=R2:B5=R2:GOSUB 8670`GoToNextLine ^(^

^)^: ` 1880 GOSUB 8590:A$=">B<":Z1=R1:B4=R1:Z2=R2:B5=R2:GOSUB 8670`GoToNextLine ^(^

^)^: ` 1910 FOR I=1 TO S3:GOSUB 8590:A$=" * ":Z1=R1:Z2=R2:GOSUB 8670:NEXT I`GoToNextLine ^(^

^)^: ` 1910 FOR I=1 TO S3:GOSUB 8590:A$=" * ":Z1=R1:Z2=R2:GOSUB 8670:NEXT I`GoToNextLine ^(^

^)^: ` 260 CLEAR 600`GoToNextLine ^(^

^)^: ` 1990 IF S+E>10 THEN IF E>10 OR D(7)=0 THEN 2060`GoToNextLine ^(^

^)^: ` 1990 IF S+E>10 THEN IF E>10 OR D(7)=0 THEN 2060`GoToNextLine ^(^

^)^: ` 2020 PRINT:PRINT TAB(10);CHR$(22);"** FATAL ERROR **";CHR$(22):PRINT"YOU'VE JUST STRANDED YOUR SHIP IN SPACE."`GoToNextLine ^(^

^)^: ` 2020 PRINT:PRINT TAB(10);CHR$(22);"** FATAL ERROR **";CHR$(22):PRINT"YOU'VE JUST STRANDED YOUR SHIP IN SPACE."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2050 PRINT"CROSS-CIRCUITING TO ENGINE ROOM!!":PRINT:GOTO 6220`GoToNextLine ^(^

^)^: ` 2050 PRINT"CROSS-CIRCUITING TO ENGINE ROOM!!":PRINT:GOTO 6220`GoToNextLine ^(^

^)^: ` 2060 PRINT:INPUT"COMMAND";A$:PRINT`GoToNextLine ^(^

^)^: ` 2060 PRINT:INPUT"COMMAND";A$:PRINT`GoToNextLine ^(^

^)^: ` 2080 FOR I=1 TO 9:IF LEFT$(A$,3)<>MID$(A1$,3*I-2,3)THEN 2160`GoToNextLine ^(^

^)^: ` 2080 FOR I=1 TO 9:IF LEFT$(A$,3)<>MID$(A1$,3*I-2,3)THEN 2160`GoToNextLine ^(^

^)^: ` 2140 ON I GOTO 2300,1980,4000,4260,4700,5530,5690,7290,6270`GoToNextLine ^(^

^)^: ` 2140 ON I GOTO 2300,1980,4000,4260,4700,5530,5690,7290,6270`GoToNextLine ^(^

^)^: ` 2160 NEXT I:PRINT"ENTER ONE OF THE FOLLOWING:"`GoToNextLine ^(^

^)^: ` 2160 NEXT I:PRINT"ENTER ONE OF THE FOLLOWING:"`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2050 PRINT"CROSS-CIRCUITING TO ENGINE ROOM!!":PRINT:GOTO 6220`GoToNextLine ^(^

^)^: ` 2300 INPUT"COURSE (0-9)";C1:IF C1=9 THEN C1=1`GoToNextLine ^(^

^)^: ` 2300 INPUT"COURSE (0-9)";C1:IF C1=9 THEN C1=1`GoToNextLine ^(^

^)^: ` 2310 IF C1>=1 AND C1<9 THEN 2350`GoToNextLine ^(^

^)^: ` 2310 IF C1>=1 AND C1<9 THEN 2350`GoToNextLine ^(^

^)^: ` 2330 PRINT"   LT. SULU: 'INCORRECT COURSE DATA, SIR!'":GOTO 1990`GoToNextLine ^(^

^)^: ` 2330 PRINT"   LT. SULU: 'INCORRECT COURSE DATA, SIR!'":GOTO 1990`GoToNextLine ^(^

^)^: ` 2350 X$="8":IF D(1)<0 THEN X$="0.2"`GoToNextLine ^(^

^)^: ` 2350 X$="8":IF D(1)<0 THEN X$="0.2"`GoToNextLine ^(^

^)^: ` 2360 PRINT"WARP FACTOR (0-";X$;")";:INPUT W1:PRINT:IF D(1)<0 AND W1>.2 THEN 2470`GoToNextLine ^(^

^)^: ` 2360 PRINT"WARP FACTOR (0-";X$;")";:INPUT W1:PRINT:IF D(1)<0 AND W1>.2 THEN 2470`GoToNextLine ^(^

^)^: ` 2380 IF W1>0 AND W1<=8 THEN 2490`GoToNextLine ^(^

^)^: ` 2380 IF W1>0 AND W1<=8 THEN 2490`GoToNextLine ^(^

^)^: ` 2390 IF W1=0 THEN 1990`GoToNextLine ^(^

^)^: ` 2390 IF W1=0 THEN 1990`GoToNextLine ^(^

^)^: ` 2420 PRINT"   CHIEF ENGINEER SCOTT: 'THE ENGINES WON'T TAKE";`GoToNextLine ^(^

^)^: ` 2420 PRINT"   CHIEF ENGINEER SCOTT: 'THE ENGINES WON'T TAKE";`GoToNextLine ^(^

^)^: ` 2430 PRINT" WARP";W1;CHR$(8);"!'":GOTO 1990`GoToNextLine ^(^

^)^: ` 2430 PRINT" WARP";W1;CHR$(8);"!'":GOTO 1990`GoToNextLine ^(^

^)^: ` 2330 PRINT"   LT. SULU: 'INCORRECT COURSE DATA, SIR!'":GOTO 1990`GoToNextLine ^(^

^)^: ` 2490 N=INT(W1*8+.5):IF E-N>=0 THEN 2590`GoToNextLine ^(^

^)^: ` 2490 N=INT(W1*8+.5):IF E-N>=0 THEN 2590`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2510 PRINT"               FOR MANEUVERING AT WARP";W1;CHR$(8);"!'"`GoToNextLine ^(^

^)^: ` 2510 PRINT"               FOR MANEUVERING AT WARP";W1;CHR$(8);"!'"`GoToNextLine ^(^

^)^: ` 2530 IF S<N-E OR D(7)<0 THEN 1990`GoToNextLine ^(^

^)^: ` 2530 IF S<N-E OR D(7)<0 THEN 1990`GoToNextLine ^(^

^)^: ` 2550 PRINT"DEFLECTOR CONTROL ROOM:  ";S;"UNITS OF ENERGY"`GoToNextLine ^(^

^)^: ` 2550 PRINT"DEFLECTOR CONTROL ROOM:  ";S;"UNITS OF ENERGY"`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 2590 FOR I=1 TO K3:IF K(I,3)=0 THEN 2700`GoToNextLine ^(^

^)^: ` 2590 FOR I=1 TO K3:IF K(I,3)=0 THEN 2700`GoToNextLine ^(^

^)^: ` 2610 A$="   ":Z1=K(I,1):Z2=K(I,2):GOSUB 8670:GOSUB 8590`GoToNextLine ^(^

^)^: ` 2610 A$="   ":Z1=K(I,1):Z2=K(I,2):GOSUB 8670:GOSUB 8590`GoToNextLine ^(^

^)^: ` 2660 K(I,1)=Z1:K(I,2)=Z2:A$="+K+":GOSUB 8670`GoToNextLine ^(^

^)^: ` 2660 K(I,1)=Z1:K(I,2)=Z2:A$="+K+":GOSUB 8670`GoToNextLine ^(^

^)^: ` 2700 NEXT I:GOSUB 6000:D1=0:D6=W1:IF W1>=1 THEN D6=1`GoToNextLine ^(^

^)^: ` 2700 NEXT I:GOSUB 6000:D1=0:D6=W1:IF W1>=1 THEN D6=1`GoToNextLine ^(^

^)^: ` 2770 FOR I=1 TO 8:IF D(I)>=0 THEN 2880`GoToNextLine ^(^

^)^: ` 2770 FOR I=1 TO 8:IF D(I)>=0 THEN 2880`GoToNextLine ^(^

^)^: ` 2790 D(I)=D(I)+D6:IF D(I)>-.1 AND D(I)<0 THEN D(I)=-.1:GOTO 2880`GoToNextLine ^(^

^)^: ` 2790 D(I)=D(I)+D6:IF D(I)>-.1 AND D(I)<0 THEN D(I)=-.1:GOTO 2880`GoToNextLine ^(^

^)^: ` 2800 IF D(I)<0 THEN 2880`GoToNextLine ^(^

^)^: ` 2800 IF D(I)<0 THEN 2880`GoToNextLine ^(^

^)^: ` 2810 IF D1<>1 THEN D1=1:PRINT"DAMAGE CONTROL REPORT:  ";`GoToNextLine ^(^

^)^: ` 2810 IF D1<>1 THEN D1=1:PRINT"DAMAGE CONTROL REPORT:  ";`GoToNextLine ^(^

^)^: ` 2840 PRINT TAB(8);:R1=I:GOSUB 8790:PRINT G2$;" REPAIR COMPLETED."`GoToNextLine ^(^

^)^: ` 2840 PRINT TAB(8);:R1=I:GOSUB 8790:PRINT G2$;" REPAIR COMPLETED."`GoToNextLine ^(^

^)^: ` 2880 NEXT I:IF RND(1)>.2 THEN 3070`GoToNextLine ^(^

^)^: ` 2880 NEXT I:IF RND(1)>.2 THEN 3070`GoToNextLine ^(^

^)^: ` 2910 R1=FNR(1):IF RND(1)>=.6 THEN 3000`GoToNextLine ^(^

^)^: ` 2910 R1=FNR(1):IF RND(1)>=.6 THEN 3000`GoToNextLine ^(^

^)^: ` 2930 D(R1)=D(R1)-(RND(1)*5+1):PRINT"DAMAGE CONTROL REPORT:  ";`GoToNextLine ^(^

^)^: ` 2930 D(R1)=D(R1)-(RND(1)*5+1):PRINT"DAMAGE CONTROL REPORT:  ";`GoToNextLine ^(^

^)^: ` 2960 GOSUB 8790:PRINT G2$;" DAMAGED":PRINT:GOTO 3070`GoToNextLine ^(^

^)^: ` 2960 GOSUB 8790:PRINT G2$;" DAMAGED":PRINT:GOTO 3070`GoToNextLine ^(^

^)^: ` 3000 D(R1)=D(R1)+RND(1)*3+1:PRINT"DAMAGE CONTROL REPORT:  ";`GoToNextLine ^(^

^)^: ` 3000 D(R1)=D(R1)+RND(1)*3+1:PRINT"DAMAGE CONTROL REPORT:  ";`GoToNextLine ^(^

^)^: ` 3030 GOSUB 8790:PRINT G2$;" STATE OF REPAIR IMPROVED":PRINT`GoToNextLine ^(^

^)^: ` 3030 GOSUB 8790:PRINT G2$;" STATE OF REPAIR IMPROVED":PRINT`GoToNextLine ^(^

^)^: ` 3070 A$="   ":Z1=INT(S1):Z2=INT(S2):GOSUB 8670`GoToNextLine ^(^

^)^: ` 3070 A$="   ":Z1=INT(S1):Z2=INT(S2):GOSUB 8670`GoToNextLine ^(^

^)^: ` 3110 X1=C(C1,1)+(C(C1+1,1)-C(C1,1))*(C1-INT(C1)):X=S1:Y=S2`GoToNextLine ^(^

^)^: ` 3110 X1=C(C1,1)+(C(C1+1,1)-C(C1,1))*(C1-INT(C1)):X=S1:Y=S2`GoToNextLine ^(^

^)^: ` 3140 X2=C(C1,2)+(C(C1+1,2)-C(C1,2))*(C1-INT(C1)):Q4=Q1:Q5=Q2`GoToNextLine ^(^

^)^: ` 3140 X2=C(C1,2)+(C(C1+1,2)-C(C1,2))*(C1-INT(C1)):Q4=Q1:Q5=Q2`GoToNextLine ^(^

^)^: ` 3170 FOR I=1 TO N:S1=S1+X1:S2=S2+X2:IF S1<1 OR S1>=9 OR S2<1 OR S2>=9 THEN 3500`GoToNextLine ^(^

^)^: ` 3170 FOR I=1 TO N:S1=S1+X1:S2=S2+X2:IF S1<1 OR S1>=9 OR S2<1 OR S2>=9 THEN 3500`GoToNextLine ^(^

^)^: ` 3240 S8=INT(S1)*24+INT(S2)*3-26:IF MID$(Q$,S8,2)="  "THEN 3360`GoToNextLine ^(^

^)^: ` 3240 S8=INT(S1)*24+INT(S2)*3-26:IF MID$(Q$,S8,2)="  "THEN 3360`GoToNextLine ^(^

^)^: ` 3320 S1=INT(S1-X1):S2=INT(S2-X2):PRINT"WARP ENGINES SHUT DOWN AT ";`GoToNextLine ^(^

^)^: ` 3320 S1=INT(S1-X1):S2=INT(S2-X2):PRINT"WARP ENGINES SHUT DOWN AT ";`GoToNextLine ^(^

^)^: ` 3350 PRINT"SECTOR";S1;CHR$(8);",";S2;"DUE TO BAD NAVAGATION":GOTO 3370`GoToNextLine ^(^

^)^: ` 3350 PRINT"SECTOR";S1;CHR$(8);",";S2;"DUE TO BAD NAVAGATION":GOTO 3370`GoToNextLine ^(^

^)^: ` 3360 NEXT I:S1=INT(S1):S2=INT(S2)`GoToNextLine ^(^

^)^: ` 3360 NEXT I:S1=INT(S1):S2=INT(S2)`GoToNextLine ^(^

^)^: ` 3370 A$="<E>":Z1=INT(S1):Z2=INT(S2):GOSUB 8670:GOSUB 3910:T8=1`GoToNextLine ^(^

^)^: ` 3370 A$="<E>":Z1=INT(S1):Z2=INT(S2):GOSUB 8670:GOSUB 3910:T8=1`GoToNextLine ^(^

^)^: ` 3430 IF W1<1 THEN T8=.1*INT(10*W1)`GoToNextLine ^(^

^)^: ` 3430 IF W1<1 THEN T8=.1*INT(10*W1)`GoToNextLine ^(^

^)^: ` 3450 T=T+T8:IF T>T0+T9 THEN 6220`GoToNextLine ^(^

^)^: ` 3450 T=T+T8:IF T>T0+T9 THEN 6220`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 3500 X=8*Q1+X+N*X1:Y=8*Q2+Y+N*X2:Q1=INT(X/8):Q2=INT(Y/8):S1=INT(X-Q1*8)`GoToNextLine ^(^

^)^: ` 3500 X=8*Q1+X+N*X1:Y=8*Q2+Y+N*X2:Q1=INT(X/8):Q2=INT(Y/8):S1=INT(X-Q1*8)`GoToNextLine ^(^

^)^: ` 3550 S2=INT(Y-Q2*8):IF S1=0 THEN Q1=Q1-1:S1=8`GoToNextLine ^(^

^)^: ` 3550 S2=INT(Y-Q2*8):IF S1=0 THEN Q1=Q1-1:S1=8`GoToNextLine ^(^

^)^: ` 3590 IF S2=0 THEN Q2=Q2-1:S2=8`GoToNextLine ^(^

^)^: ` 3590 IF S2=0 THEN Q2=Q2-1:S2=8`GoToNextLine ^(^

^)^: ` 3620 X5=0:IF Q1<1 THEN X5=1:Q1=1:S1=1`GoToNextLine ^(^

^)^: ` 3620 X5=0:IF Q1<1 THEN X5=1:Q1=1:S1=1`GoToNextLine ^(^

^)^: ` 3670 IF Q1>8 THEN X5=1:Q1=8:S1=8`GoToNextLine ^(^

^)^: ` 3670 IF Q1>8 THEN X5=1:Q1=8:S1=8`GoToNextLine ^(^

^)^: ` 3710 IF Q2<1 THEN X5=1:Q2=1:S2=1`GoToNextLine ^(^

^)^: ` 3710 IF Q2<1 THEN X5=1:Q2=1:S2=1`GoToNextLine ^(^

^)^: ` 3750 IF Q2>8 THEN X5=1:Q2=8:S2=8`GoToNextLine ^(^

^)^: ` 3750 IF Q2>8 THEN X5=1:Q2=8:S2=8`GoToNextLine ^(^

^)^: ` 2390 IF W1=0 THEN 1990`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 3840 PRINT"  AT SECTOR";S1;CHR$(8);",";S2;"OF QUADRANT";Q1;CHR$(8);",";Q2;CHR$(8);".'"`GoToNextLine ^(^

^)^: ` 3840 PRINT"  AT SECTOR";S1;CHR$(8);",";S2;"OF QUADRANT";Q1;CHR$(8);",";Q2;CHR$(8);".'"`GoToNextLine ^(^

^)^: ` 3850 IF T>T0+T9 THEN 6220`GoToNextLine ^(^

^)^: ` 3850 IF T>T0+T9 THEN 6220`GoToNextLine ^(^

^)^: ` 3860 IF 8*Q1+Q2=8*Q4+Q5 THEN 3370`GoToNextLine ^(^

^)^: ` 3860 IF 8*Q1+Q2=8*Q4+Q5 THEN 3370`GoToNextLine ^(^

^)^: ` 3870 T=T+1:GOSUB 3910:GOTO 1320`GoToNextLine ^(^

^)^: ` 3870 T=T+1:GOSUB 3910:GOTO 1320`GoToNextLine ^(^

^)^: ` 3910 E=E-N-10:IF E>=0 THEN RETURN`GoToNextLine ^(^

^)^: ` 3910 E=E-N-10:IF E>=0 THEN RETURN`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 3940 S=S+E:E=0:IF S<=0 THEN S=0`GoToNextLine ^(^

^)^: ` 3940 S=S+E:E=0:IF S<=0 THEN S=0`GoToNextLine ^(^

^)^: ` 3980 RETURN`GoToNextLine ^(^

^)^: ` 3980 RETURN`GoToNextLine ^(^

^)^: ` 4000 IF D(3)<0 THEN PRINT"LONG RANGE SENSORS ARE INOPERABLE.":GOTO 1990`GoToNextLine ^(^

^)^: ` 4000 IF D(3)<0 THEN PRINT"LONG RANGE SENSORS ARE INOPERABLE.":GOTO 1990`GoToNextLine ^(^

^)^: ` 4030 PRINT"LONG RANGE SCAN FOR QUADRANT";Q1;CHR$(8);",";Q2:PRINT`GoToNextLine ^(^

^)^: ` 4030 PRINT"LONG RANGE SCAN FOR QUADRANT";Q1;CHR$(8);",";Q2:PRINT`GoToNextLine ^(^

^)^: ` 4040 O1$="-------------------":PRINT O1$`GoToNextLine ^(^

^)^: ` 4040 O1$="-------------------":PRINT O1$`GoToNextLine ^(^

^)^: ` 4060 FOR I=Q1-1 TO Q1+1:N(1)=-1:N(2)=-2:N(3)=-3:FOR J=Q2-1 TO Q2+1`GoToNextLine ^(^

^)^: ` 4060 FOR I=Q1-1 TO Q1+1:N(1)=-1:N(2)=-2:N(3)=-3:FOR J=Q2-1 TO Q2+1`GoToNextLine ^(^

^)^: ` 4120 IF I>0 AND I<9 AND J>0 AND J<9 THEN N(J-Q2+2)=G(I,J):Z(I,J)=G(I,J)`GoToNextLine ^(^

^)^: ` 4120 IF I>0 AND I<9 AND J>0 AND J<9 THEN N(J-Q2+2)=G(I,J):Z(I,J)=G(I,J)`GoToNextLine ^(^

^)^: ` 4180 NEXT J:FOR L=1 TO 3:PRINT"| ";:IF N(L)<0 THEN PRINT"*** ";:GOTO 4230`GoToNextLine ^(^

^)^: ` 4180 NEXT J:FOR L=1 TO 3:PRINT"| ";:IF N(L)<0 THEN PRINT"*** ";:GOTO 4230`GoToNextLine ^(^

^)^: ` 4210 PRINT RIGHT$(STR$(N(L)+1000),3);" ";`GoToNextLine ^(^

^)^: ` 4210 PRINT RIGHT$(STR$(N(L)+1000),3);" ";`GoToNextLine ^(^

^)^: ` 4230 NEXT L:PRINT"|":PRINT O1$:NEXT I:GOTO 1990`GoToNextLine ^(^

^)^: ` 4230 NEXT L:PRINT"|":PRINT O1$:NEXT I:GOTO 1990`GoToNextLine ^(^

^)^: ` 4260 IF D(4)<0 THEN PRINT"PHASERS INOPERATIVE.":GOTO 1990`GoToNextLine ^(^

^)^: ` 4260 IF D(4)<0 THEN PRINT"PHASERS INOPERATIVE.":GOTO 1990`GoToNextLine ^(^

^)^: ` 4265 IF K3>0 THEN 4330`GoToNextLine ^(^

^)^: ` 4265 IF K3>0 THEN 4330`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2330 PRINT"   LT. SULU: 'INCORRECT COURSE DATA, SIR!'":GOTO 1990`GoToNextLine ^(^

^)^: ` 4330 IF D(8)<0 THEN PRINT"COMPUTER FAILURE HAMPERS ACCURACY."`GoToNextLine ^(^

^)^: ` 4330 IF D(8)<0 THEN PRINT"COMPUTER FAILURE HAMPERS ACCURACY."`GoToNextLine ^(^

^)^: ` 2420 PRINT"   CHIEF ENGINEER SCOTT: 'THE ENGINES WON'T TAKE";`GoToNextLine ^(^

^)^: ` 4360 PRINT"ENERGY AVAILABLE =";E;"UNITS"`GoToNextLine ^(^

^)^: ` 4360 PRINT"ENERGY AVAILABLE =";E;"UNITS"`GoToNextLine ^(^

^)^: ` 4370 INPUT"NUMBER OF UNITS TO FIRE";X:IF X<=0 THEN 1990`GoToNextLine ^(^

^)^: ` 4370 INPUT"NUMBER OF UNITS TO FIRE";X:IF X<=0 THEN 1990`GoToNextLine ^(^

^)^: ` 4400 IF E-X<0 THEN 4360`GoToNextLine ^(^

^)^: ` 4400 IF E-X<0 THEN 4360`GoToNextLine ^(^

^)^: ` 4410 E=E-X:IF D(7)<0 THEN X=X*RND(1)`GoToNextLine ^(^

^)^: ` 4410 E=E-X:IF D(7)<0 THEN X=X*RND(1)`GoToNextLine ^(^

^)^: ` 4450 H1=INT(X/K3):FOR I=1 TO 3:IF K(I,3)<=0 THEN 4670`GoToNextLine ^(^

^)^: ` 4450 H1=INT(X/K3):FOR I=1 TO 3:IF K(I,3)<=0 THEN 4670`GoToNextLine ^(^

^)^: ` 4480 H=INT((H1/FND(0))*(RND(1)+2)):IF H>.15*K(I,3)THEN 4530`GoToNextLine ^(^

^)^: ` 4480 H=INT((H1/FND(0))*(RND(1)+2)):IF H>.15*K(I,3)THEN 4530`GoToNextLine ^(^

^)^: ` 4500 PRINT"SENSORS SHOW NO DAMAGE TO ENEMY AT";K(I,1);CHR$(8);",";K(I,2);CHR$(8);".":GOTO 4670`GoToNextLine ^(^

^)^: ` 4500 PRINT"SENSORS SHOW NO DAMAGE TO ENEMY AT";K(I,1);CHR$(8);",";K(I,2);CHR$(8);".":GOTO 4670`GoToNextLine ^(^

^)^: ` 4530 K(I,3)=K(I,3)-H:PRINT H;"UNIT HIT ON KLINGON AT SECTOR";K(I,1);CHR$(8);",";`GoToNextLine ^(^

^)^: ` 4530 K(I,3)=K(I,3)-H:PRINT H;"UNIT HIT ON KLINGON AT SECTOR";K(I,1);CHR$(8);",";`GoToNextLine ^(^

^)^: ` 4550 PRINT K(I,2);CHR$(8);".":IF K(I,3)<=0 THEN PRINT:PRINT CHR$(22);"*** KLINGON DESTROYED ***";CHR$(22):PRINT:GOTO 4580`GoToNextLine ^(^

^)^: ` 4550 PRINT K(I,2);CHR$(8);".":IF K(I,3)<=0 THEN PRINT:PRINT CHR$(22);"*** KLINGON DESTROYED ***";CHR$(22):PRINT:GOTO 4580`GoToNextLine ^(^

^)^: ` 4560 PRINT" (SENSORS SHOW";K(I,3);"UNITS REMAINING)":GOTO 4670`GoToNextLine ^(^

^)^: ` 4560 PRINT" (SENSORS SHOW";K(I,3);"UNITS REMAINING)":GOTO 4670`GoToNextLine ^(^

^)^: ` 4580 K3=K3-1:K9=K9-1:Z1=K(I,1):Z2=K(I,2):A$="   ":GOSUB 8670`GoToNextLine ^(^

^)^: ` 4580 K3=K3-1:K9=K9-1:Z1=K(I,1):Z2=K(I,2):A$="   ":GOSUB 8670`GoToNextLine ^(^

^)^: ` 4650 K(I,3)=0:G(Q1,Q2)=G(Q1,Q2)-100:Z(Q1,Q2)=G(Q1,Q2):IF K9<=0 THEN 6370`GoToNextLine ^(^

^)^: ` 4650 K(I,3)=0:G(Q1,Q2)=G(Q1,Q2)-100:Z(Q1,Q2)=G(Q1,Q2):IF K9<=0 THEN 6370`GoToNextLine ^(^

^)^: ` 4670 NEXT I:GOSUB 6000:GOTO 1990`GoToNextLine ^(^

^)^: ` 4670 NEXT I:GOSUB 6000:GOTO 1990`GoToNextLine ^(^

^)^: ` 4700 IF P<=0 THEN PRINT"ALL PHOTON TORPEDOES EXPENDED.":GOTO 1990`GoToNextLine ^(^

^)^: ` 4700 IF P<=0 THEN PRINT"ALL PHOTON TORPEDOES EXPENDED.":GOTO 1990`GoToNextLine ^(^

^)^: ` 4730 IF D(5)<0 THEN PRINT"PHOTON TUBES ARE NOT OPERATIONAL.":GOTO 1990`GoToNextLine ^(^

^)^: ` 4730 IF D(5)<0 THEN PRINT"PHOTON TUBES ARE NOT OPERATIONAL.":GOTO 1990`GoToNextLine ^(^

^)^: ` 2300 INPUT"COURSE (0-9)";C1:IF C1=9 THEN C1=1`GoToNextLine ^(^

^)^: ` 2310 IF C1>=1 AND C1<9 THEN 2350`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 4850 X1=C(C1,1)+(C(C1+1,1)-C(C1,1))*(C1-INT(C1)):E=E-2:P=P-1`GoToNextLine ^(^

^)^: ` 4850 X1=C(C1,1)+(C(C1+1,1)-C(C1,1))*(C1-INT(C1)):E=E-2:P=P-1`GoToNextLine ^(^

^)^: ` 3110 X1=C(C1,1)+(C(C1+1,1)-C(C1,1))*(C1-INT(C1)):X=S1:Y=S2`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 4920 X=X+X1:Y=Y+X2:X3=INT(X+.5):Y3=INT(Y+.5)`GoToNextLine ^(^

^)^: ` 4920 X=X+X1:Y=Y+X2:X3=INT(X+.5):Y3=INT(Y+.5)`GoToNextLine ^(^

^)^: ` 1390 IF Q1<1 OR Q1>8 OR Q2<1 OR Q2>8 THEN 1600`GoToNextLine ^(^

^)^: ` 5000 PRINT"               ";X3;CHR$(8);",";Y3:A$="   ":Z1=X:Z2=Y:GOSUB 8830`GoToNextLine ^(^

^)^: ` 5000 PRINT"               ";X3;CHR$(8);",";Y3:A$="   ":Z1=X:Z2=Y:GOSUB 8830`GoToNextLine ^(^

^)^: ` 1100 IF B9<>0 THEN 1200`GoToNextLine ^(^

^)^: ` 5060 A$="+K+":Z1=X:Z2=Y:GOSUB 8830:IF Z3=0 THEN 5210`GoToNextLine ^(^

^)^: ` 5060 A$="+K+":Z1=X:Z2=Y:GOSUB 8830:IF Z3=0 THEN 5210`GoToNextLine ^(^

^)^: ` 5110 PRINT:PRINT CHR$(22);"*** KLINGON DESTROYED ***";CHR$(22):PRINT:K3=K3-1:K9=K9-1:IF K9<=0 THEN 6370`GoToNextLine ^(^

^)^: ` 5110 PRINT:PRINT CHR$(22);"*** KLINGON DESTROYED ***";CHR$(22):PRINT:K3=K3-1:K9=K9-1:IF K9<=0 THEN 6370`GoToNextLine ^(^

^)^: ` 5150 FOR I=1 TO 3:IF X3=K(I,1)AND Y3=K(I,2)THEN 5190`GoToNextLine ^(^

^)^: ` 5150 FOR I=1 TO 3:IF X3=K(I,1)AND Y3=K(I,2)THEN 5190`GoToNextLine ^(^

^)^: ` 5180 NEXT I:I=3`GoToNextLine ^(^

^)^: ` 5180 NEXT I:I=3`GoToNextLine ^(^

^)^: ` 5190 K(I,3)=0:GOTO 5430`GoToNextLine ^(^

^)^: ` 5190 K(I,3)=0:GOTO 5430`GoToNextLine ^(^

^)^: ` 5060 A$="+K+":Z1=X:Z2=Y:GOSUB 8830:IF Z3=0 THEN 5210`GoToNextLine ^(^

^)^: ` 5260 PRINT"STAR AT";X3;",";Y3;"ABSORBED TORPEDO ENERGY.":GOSUB 6000:GOTO 1990`GoToNextLine ^(^

^)^: ` 5260 PRINT"STAR AT";X3;",";Y3;"ABSORBED TORPEDO ENERGY.":GOSUB 6000:GOTO 1990`GoToNextLine ^(^

^)^: ` 5060 A$="+K+":Z1=X:Z2=Y:GOSUB 8830:IF Z3=0 THEN 5210`GoToNextLine ^(^

^)^: ` 5330 PRINT CHR$(22);"*** STARBASE DESTROYED ***";CHR$(22):B3=B3-1:B9=B9-1`GoToNextLine ^(^

^)^: ` 5330 PRINT CHR$(22);"*** STARBASE DESTROYED ***";CHR$(22):B3=B3-1:B9=B9-1`GoToNextLine ^(^

^)^: ` 5360 IF B9>0 OR K9>T-T0-T9 THEN 5400`GoToNextLine ^(^

^)^: ` 5360 IF B9>0 OR K9>T-T0-T9 THEN 5400`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 5410 PRINT"COURT MARTIAL!":D0=0`GoToNextLine ^(^

^)^: ` 5410 PRINT"COURT MARTIAL!":D0=0`GoToNextLine ^(^

^)^: ` 5430 Z1=X:Z2=Y:A$="   ":GOSUB 8670`GoToNextLine ^(^

^)^: ` 5430 Z1=X:Z2=Y:A$="   ":GOSUB 8670`GoToNextLine ^(^

^)^: ` 5470 G(Q1,Q2)=K3*100+B3*10+S3:Z(Q1,Q2)=G(Q1,Q2):GOSUB 6000:GOTO 1990`GoToNextLine ^(^

^)^: ` 5470 G(Q1,Q2)=K3*100+B3*10+S3:Z(Q1,Q2)=G(Q1,Q2):GOSUB 6000:GOTO 1990`GoToNextLine ^(^

^)^: ` 5490 PRINT"TORPEDO MISSED.":PRINT:GOSUB 6000:GOTO 1990`GoToNextLine ^(^

^)^: ` 5490 PRINT"TORPEDO MISSED.":PRINT:GOSUB 6000:GOTO 1990`GoToNextLine ^(^

^)^: ` 5530 IF D(7)<0 THEN PRINT"SHIELD CONTROL INOPERABLE.":GOTO 1990`GoToNextLine ^(^

^)^: ` 5530 IF D(7)<0 THEN PRINT"SHIELD CONTROL INOPERABLE.":GOTO 1990`GoToNextLine ^(^

^)^: ` 5560 PRINT"ENERGY AVAILABLE =";E+S;:INPUT"NUMBER OF UNITS TO SHIELDS";X`GoToNextLine ^(^

^)^: ` 5560 PRINT"ENERGY AVAILABLE =";E+S;:INPUT"NUMBER OF UNITS TO SHIELDS";X`GoToNextLine ^(^

^)^: ` 5580 IF X<0 OR S=X THEN PRINT"<SHIELDS UNCHANGED>":GOTO 1990`GoToNextLine ^(^

^)^: ` 5580 IF X<0 OR S=X THEN PRINT"<SHIELDS UNCHANGED>":GOTO 1990`GoToNextLine ^(^

^)^: ` 5590 IF X<=E+S THEN 5630`GoToNextLine ^(^

^)^: ` 5590 IF X<=E+S THEN 5630`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2330 PRINT"   LT. SULU: 'INCORRECT COURSE DATA, SIR!'":GOTO 1990`GoToNextLine ^(^

^)^: ` 5630 E=E+S-X:S=X:PRINT"DEFLECTOR CONTROL ROOM:"`GoToNextLine ^(^

^)^: ` 5630 E=E+S-X:S=X:PRINT"DEFLECTOR CONTROL ROOM:"`GoToNextLine ^(^

^)^: ` 5660 PRINT"  'SHIELDS NOW AT";INT(S);"UNITS PER YOUR COMMAND.'":GOTO 1990`GoToNextLine ^(^

^)^: ` 5660 PRINT"  'SHIELDS NOW AT";INT(S);"UNITS PER YOUR COMMAND.'":GOTO 1990`GoToNextLine ^(^

^)^: ` 5690 IF D(6)>=0 THEN 5910`GoToNextLine ^(^

^)^: ` 5690 IF D(6)>=0 THEN 5910`GoToNextLine ^(^

^)^: ` 5700 PRINT"DAMAGE CONTROL REPORT NOT AVAILABLE.":IF D0=0 THEN 1990`GoToNextLine ^(^

^)^: ` 5700 PRINT"DAMAGE CONTROL REPORT NOT AVAILABLE.":IF D0=0 THEN 1990`GoToNextLine ^(^

^)^: ` 5720 D3=0:FOR I=1 TO 8:IF D(I)<0 THEN D3=D3+.1`GoToNextLine ^(^

^)^: ` 5720 D3=0:FOR I=1 TO 8:IF D(I)<0 THEN D3=D3+.1`GoToNextLine ^(^

^)^: ` 5760 NEXT I:IF D3=0 THEN 1990`GoToNextLine ^(^

^)^: ` 5760 NEXT I:IF D3=0 THEN 1990`GoToNextLine ^(^

^)^: ` 5780 PRINT:D3=D3+D4:IF D3>=1 THEN D3=.9`GoToNextLine ^(^

^)^: ` 5780 PRINT:D3=D3+D4:IF D3>=1 THEN D3=.9`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 5820 PRINT"ESTIMATED TIME TO REPAIR:";.01*INT(100*D3);"STARDATES."`GoToNextLine ^(^

^)^: ` 5820 PRINT"ESTIMATED TIME TO REPAIR:";.01*INT(100*D3);"STARDATES."`GoToNextLine ^(^

^)^: ` 5840 INPUT"WILL YOU AUTHORIZE THE REPAIR ORDER (Y/N)";A$`GoToNextLine ^(^

^)^: ` 5840 INPUT"WILL YOU AUTHORIZE THE REPAIR ORDER (Y/N)";A$`GoToNextLine ^(^

^)^: ` 5860 IF A$<>"Y"THEN 1990`GoToNextLine ^(^

^)^: ` 5860 IF A$<>"Y"THEN 1990`GoToNextLine ^(^

^)^: ` 5870 FOR I=1 TO 8:IF D(I)<0 THEN D(I)=0`GoToNextLine ^(^

^)^: ` 5870 FOR I=1 TO 8:IF D(I)<0 THEN D(I)=0`GoToNextLine ^(^

^)^: ` 5890 NEXT I:T=T+D3+.1`GoToNextLine ^(^

^)^: ` 5890 NEXT I:T=T+D3+.1`GoToNextLine ^(^

^)^: ` 5910 PRINT:PRINT"DEVICE             STATE OF REPAIR":PRINT"------             ---------------":FOR R1=1 TO 8`GoToNextLine ^(^

^)^: ` 5910 PRINT:PRINT"DEVICE             STATE OF REPAIR":PRINT"------             ---------------":FOR R1=1 TO 8`GoToNextLine ^(^

^)^: ` 5920 GOSUB 8790:PRINT G2$;LEFT$(Z$,25-LEN(G2$));INT(D(R1)*100)*.01`GoToNextLine ^(^

^)^: ` 5920 GOSUB 8790:PRINT G2$;LEFT$(Z$,25-LEN(G2$));INT(D(R1)*100)*.01`GoToNextLine ^(^

^)^: ` 5950 NEXT R1:PRINT:IF D0<>0 THEN 5720`GoToNextLine ^(^

^)^: ` 5950 NEXT R1:PRINT:IF D0<>0 THEN 5720`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 6000 IF K3<=0 THEN RETURN`GoToNextLine ^(^

^)^: ` 6000 IF K3<=0 THEN RETURN`GoToNextLine ^(^

^)^: ` 6010 IF D0<>0 THEN PRINT"STARBASE SHIELDS PROTECT THE ENTERPRISE.":RETURN`GoToNextLine ^(^

^)^: ` 6010 IF D0<>0 THEN PRINT"STARBASE SHIELDS PROTECT THE ENTERPRISE.":RETURN`GoToNextLine ^(^

^)^: ` 6040 FOR I=1 TO 3:IF K(I,3)<=0 THEN 6200`GoToNextLine ^(^

^)^: ` 6040 FOR I=1 TO 3:IF K(I,3)<=0 THEN 6200`GoToNextLine ^(^

^)^: ` 6060 H=INT((K(I,3)/FND(1))*(2+RND(1))):S=S-H:K(I,3)=K(I,3)/(3+RND(0))`GoToNextLine ^(^

^)^: ` 6060 H=INT((K(I,3)/FND(1))*(2+RND(1))):S=S-H:K(I,3)=K(I,3)/(3+RND(0))`GoToNextLine ^(^

^)^: ` 6080 PRINT:PRINT H;"UNIT HIT ON ENTERPRISE FROM SECTOR";K(I,1);CHR$(8);",";K(I,2);CHR$(8);"."`GoToNextLine ^(^

^)^: ` 6080 PRINT:PRINT H;"UNIT HIT ON ENTERPRISE FROM SECTOR";K(I,1);CHR$(8);",";K(I,2);CHR$(8);"."`GoToNextLine ^(^

^)^: ` 6090 IF S<=0 THEN 6240`GoToNextLine ^(^

^)^: ` 6090 IF S<=0 THEN 6240`GoToNextLine ^(^

^)^: ` 6100 PRINT"      <SHIELDS DOWN TO";S;"UNITS>":IF H<20 THEN 6200`GoToNextLine ^(^

^)^: ` 6100 PRINT"      <SHIELDS DOWN TO";S;"UNITS>":IF H<20 THEN 6200`GoToNextLine ^(^

^)^: ` 6120 IF RND(1)>.6 OR H/S<=.02 THEN 6200`GoToNextLine ^(^

^)^: ` 6120 IF RND(1)>.6 OR H/S<=.02 THEN 6200`GoToNextLine ^(^

^)^: ` 6140 R1=FNR(1):D(R1)=D(R1)-H/S-.5*RND(1):GOSUB 8790`GoToNextLine ^(^

^)^: ` 6140 R1=FNR(1):D(R1)=D(R1)-H/S-.5*RND(1):GOSUB 8790`GoToNextLine ^(^

^)^: ` 6170 PRINT"DAMAGE CONTROL: '";G2$;" DAMAGED BY THE HIT'"`GoToNextLine ^(^

^)^: ` 6170 PRINT"DAMAGE CONTROL: '";G2$;" DAMAGED BY THE HIT'"`GoToNextLine ^(^

^)^: ` 6200 NEXT I:RETURN`GoToNextLine ^(^

^)^: ` 6200 NEXT I:RETURN`GoToNextLine ^(^

^)^: ` 6220 PRINT:PRINT"IT IS STARDATE";T;CHR$(8);".":PRINT:GOTO 6270`GoToNextLine ^(^

^)^: ` 6220 PRINT:PRINT"IT IS STARDATE";T;CHR$(8);".":PRINT:GOTO 6270`GoToNextLine ^(^

^)^: ` 6240 PRINT:PRINT"THE ENTERPRISE HAS BEEN DESTROYED.  THE FEDERATION ";`GoToNextLine ^(^

^)^: ` 6240 PRINT:PRINT"THE ENTERPRISE HAS BEEN DESTROYED.  THE FEDERATION ";`GoToNextLine ^(^

^)^: ` 2330 PRINT"   LT. SULU: 'INCORRECT COURSE DATA, SIR!'":GOTO 1990`GoToNextLine ^(^

^)^: ` 6270 PRINT"THERE WERE";K9;"KLINGON BATTLE CRUISERS LEFT AT"`GoToNextLine ^(^

^)^: ` 6270 PRINT"THERE WERE";K9;"KLINGON BATTLE CRUISERS LEFT AT"`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 6290 PRINT:PRINT:IF B9=0 THEN 6360`GoToNextLine ^(^

^)^: ` 6290 PRINT:PRINT:IF B9=0 THEN 6360`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 6330 INPUT"LET HIM STEP FORWARD AND ENTER 'AYE'";A$:IF A$="AYE"THEN 10`GoToNextLine ^(^

^)^: ` 6330 INPUT"LET HIM STEP FORWARD AND ENTER 'AYE'";A$:IF A$="AYE"THEN 10`GoToNextLine ^(^

^)^: ` 6360 PRINT:PRINT "BACK TO SYSTEM.":SYSTEM`GoToNextLine ^(^

^)^: ` 6360 PRINT:PRINT "BACK TO SYSTEM.":SYSTEM`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 6380 PRINT"MENACING THE FEDERATION HAS BEEN DESTROYED.":PRINT`GoToNextLine ^(^

^)^: ` 6380 PRINT"MENACING THE FEDERATION HAS BEEN DESTROYED.":PRINT`GoToNextLine ^(^

^)^: ` 6400 PRINT"YOUR EFFICIENCY RATING IS";1000*(K7/(T-T0))^2:GOTO 6290`GoToNextLine ^(^

^)^: ` 6400 PRINT"YOUR EFFICIENCY RATING IS";1000*(K7/(T-T0))^2:GOTO 6290`GoToNextLine ^(^

^)^: ` 6430 FOR I=S1-1 TO S1+1:FOR J=S2-1 TO S2+1`GoToNextLine ^(^

^)^: ` 6430 FOR I=S1-1 TO S1+1:FOR J=S2-1 TO S2+1`GoToNextLine ^(^

^)^: ` 6450 IF INT(I+.5)<1 OR INT(I+.5)>8 OR INT(J+.5)<1 OR INT(J+.5)>8 THEN 6540`GoToNextLine ^(^

^)^: ` 6450 IF INT(I+.5)<1 OR INT(I+.5)>8 OR INT(J+.5)<1 OR INT(J+.5)>8 THEN 6540`GoToNextLine ^(^

^)^: ` 5060 A$="+K+":Z1=X:Z2=Y:GOSUB 8830:IF Z3=0 THEN 5210`GoToNextLine ^(^

^)^: ` 6540 NEXT J:NEXT I:D0=0:GOTO 6650`GoToNextLine ^(^

^)^: ` 6540 NEXT J:NEXT I:D0=0:GOTO 6650`GoToNextLine ^(^

^)^: ` 6580 D0=1:C$="DOCKED":E=E0:P=P0`GoToNextLine ^(^

^)^: ` 6580 D0=1:C$="DOCKED":E=E0:P=P0`GoToNextLine ^(^

^)^: ` 6620 PRINT"SHIELDS DROPPED FOR DOCKING PURPOSES.":S=0:GOTO 6720`GoToNextLine ^(^

^)^: ` 6620 PRINT"SHIELDS DROPPED FOR DOCKING PURPOSES.":S=0:GOTO 6720`GoToNextLine ^(^

^)^: ` 6650 IF K3>0 THEN C$="*RED*":GOTO 6720`GoToNextLine ^(^

^)^: ` 6650 IF K3>0 THEN C$="*RED*":GOTO 6720`GoToNextLine ^(^

^)^: ` 6660 C$="GREEN":IF E<E0*.1 THEN C$="YELLOW"`GoToNextLine ^(^

^)^: ` 6660 C$="GREEN":IF E<E0*.1 THEN C$="YELLOW"`GoToNextLine ^(^

^)^: ` 6720 IF D(2)>=0 THEN 6770`GoToNextLine ^(^

^)^: ` 6720 IF D(2)>=0 THEN 6770`GoToNextLine ^(^

^)^: ` 6730 PRINT:PRINT"*** SHORT RANGE SENSORS ARE OUT ***":PRINT:RETURN`GoToNextLine ^(^

^)^: ` 6730 PRINT:PRINT"*** SHORT RANGE SENSORS ARE OUT ***":PRINT:RETURN`GoToNextLine ^(^

^)^: ` 6770 O1$="   +--1---2---3---4---5---6---7---8-+":PRINT O1$:FOR I=1 TO 8:PRINT I;"|";`GoToNextLine ^(^

^)^: ` 6770 O1$="   +--1---2---3---4---5---6---7---8-+":PRINT O1$:FOR I=1 TO 8:PRINT I;"|";`GoToNextLine ^(^

^)^: ` 6820 FOR J=(I-1)*24+1 TO(I-1)*24+22 STEP 3:PRINT" ";MID$(Q$,J,3);:NEXT J:PRINT"|";I;`GoToNextLine ^(^

^)^: ` 6820 FOR J=(I-1)*24+1 TO(I-1)*24+22 STEP 3:PRINT" ";MID$(Q$,J,3);:NEXT J:PRINT"|";I;`GoToNextLine ^(^

^)^: ` 6830 ON I GOTO 6850,6900,6960,7020,7070,7120,7180,7240`GoToNextLine ^(^

^)^: ` 6830 ON I GOTO 6850,6900,6960,7020,7070,7120,7180,7240`GoToNextLine ^(^

^)^: ` 6850 PRINT"        STARDATE          ";:PRINT USING"####.#";INT(T*10)*.1:GOTO 7260`GoToNextLine ^(^

^)^: ` 6850 PRINT"        STARDATE          ";:PRINT USING"####.#";INT(T*10)*.1:GOTO 7260`GoToNextLine ^(^

^)^: ` 6900 PRINT"        CONDITION          ";:IF C$="*RED*" THEN PRINT CHR$(22);"*RED*";CHR$(22) ELSE IF C$="DOCKED" THEN PRINT CHR$(22);"DOCKED";CHR$(22) ELSE PRINT C$`GoToNextLine ^(^

^)^: ` 6900 PRINT"        CONDITION          ";:IF C$="*RED*" THEN PRINT CHR$(22);"*RED*";CHR$(22) ELSE IF C$="DOCKED" THEN PRINT CHR$(22);"DOCKED";CHR$(22) ELSE PRINT C$`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 4030 PRINT"LONG RANGE SCAN FOR QUADRANT";Q1;CHR$(8);",";Q2:PRINT`GoToNextLine ^(^

^)^: ` 7020 PRINT"        SECTOR             ";S1;CHR$(8);",";S2;CHR$(8):GOTO 7260`GoToNextLine ^(^

^)^: ` 7020 PRINT"        SECTOR             ";S1;CHR$(8);",";S2;CHR$(8):GOTO 7260`GoToNextLine ^(^

^)^: ` 7070 PRINT"        PHOTON TORPEDOES  ";:PRINT USING"######";INT(P):GOTO 7260`GoToNextLine ^(^

^)^: ` 7070 PRINT"        PHOTON TORPEDOES  ";:PRINT USING"######";INT(P):GOTO 7260`GoToNextLine ^(^

^)^: ` 7120 PRINT"        TOTAL ENERGY      ";:PRINT USING"######";INT(E+S):GOTO 7260`GoToNextLine ^(^

^)^: ` 7120 PRINT"        TOTAL ENERGY      ";:PRINT USING"######";INT(E+S):GOTO 7260`GoToNextLine ^(^

^)^: ` 7180 PRINT"        SHIELDS           ";:PRINT USING"######";INT(S):GOTO 7260`GoToNextLine ^(^

^)^: ` 7180 PRINT"        SHIELDS           ";:PRINT USING"######";INT(S):GOTO 7260`GoToNextLine ^(^

^)^: ` 7240 PRINT"        KLINGONS REMAINING";:PRINT USING"######";INT(K9)`GoToNextLine ^(^

^)^: ` 7240 PRINT"        KLINGONS REMAINING";:PRINT USING"######";INT(K9)`GoToNextLine ^(^

^)^: ` 7260 NEXT I:PRINT O1$:RETURN`GoToNextLine ^(^

^)^: ` 7260 NEXT I:PRINT O1$:RETURN`GoToNextLine ^(^

^)^: ` 7290 IF D(8)<0 THEN PRINT"COMPUTER DISABLED.":GOTO 1990`GoToNextLine ^(^

^)^: ` 7290 IF D(8)<0 THEN PRINT"COMPUTER DISABLED.":GOTO 1990`GoToNextLine ^(^

^)^: ` 7320 INPUT"COMPUTER ACTIVE AND AWAITING COMMAND";A:IF A<0 THEN 1990`GoToNextLine ^(^

^)^: ` 7320 INPUT"COMPUTER ACTIVE AND AWAITING COMMAND";A:IF A<0 THEN 1990`GoToNextLine ^(^

^)^: ` 7350 PRINT:H8=1:ON A+1 GOTO 7540,7900,8070,8500,8150,7400`GoToNextLine ^(^

^)^: ` 7350 PRINT:H8=1:ON A+1 GOTO 7540,7900,8070,8500,8150,7400`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 6380 PRINT"MENACING THE FEDERATION HAS BEEN DESTROYED.":PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2050 PRINT"CROSS-CIRCUITING TO ENGINE ROOM!!":PRINT:GOTO 6220`GoToNextLine ^(^

^)^: ` 7400 H8=0:G5=1:PRINT"                        THE GALAXY":GOTO 7550`GoToNextLine ^(^

^)^: ` 7400 H8=0:G5=1:PRINT"                        THE GALAXY":GOTO 7550`GoToNextLine ^(^

^)^: ` 30 REM`GoToNextLine ^(^

^)^: ` 30 REM`GoToNextLine ^(^

^)^: ` 7543 PRINT:PRINT"       ";`GoToNextLine ^(^

^)^: ` 7543 PRINT:PRINT"       ";`GoToNextLine ^(^

^)^: ` 4030 PRINT"LONG RANGE SCAN FOR QUADRANT";Q1;CHR$(8);",";Q2:PRINT`GoToNextLine ^(^

^)^: ` 150 PRINT`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 270 Z$="                         "`GoToNextLine ^(^

^)^: ` 7570 PRINT O1$:FOR I=1 TO 8:PRINT I;" ";:IF H8=0 THEN 7740`GoToNextLine ^(^

^)^: ` 7570 PRINT O1$:FOR I=1 TO 8:PRINT I;" ";:IF H8=0 THEN 7740`GoToNextLine ^(^

^)^: ` 7630 FOR J=1 TO 8:PRINT"| ";:IF Z(I,J)=0 THEN PRINT"*** ";:GOTO 7720`GoToNextLine ^(^

^)^: ` 7630 FOR J=1 TO 8:PRINT"| ";:IF Z(I,J)=0 THEN PRINT"*** ";:GOTO 7720`GoToNextLine ^(^

^)^: ` 7700 PRINT RIGHT$(STR$(Z(I,J)+1000),3);" ";`GoToNextLine ^(^

^)^: ` 7700 PRINT RIGHT$(STR$(Z(I,J)+1000),3);" ";`GoToNextLine ^(^

^)^: ` 7720 IF J=8 THEN PRINT "|"`GoToNextLine ^(^

^)^: ` 7720 IF J=8 THEN PRINT "|"`GoToNextLine ^(^

^)^: ` 7721 NEXT J:GOTO 7850`GoToNextLine ^(^

^)^: ` 7721 NEXT J:GOTO 7850`GoToNextLine ^(^

^)^: ` 7740 Z4=I:Z5=1:GOSUB 9030:J0=INT(15-.5*LEN(G2$)):PRINT TAB(J0);G2$;`GoToNextLine ^(^

^)^: ` 7740 Z4=I:Z5=1:GOSUB 9030:J0=INT(15-.5*LEN(G2$)):PRINT TAB(J0);G2$;`GoToNextLine ^(^

^)^: ` 7800 Z5=5:GOSUB 9030:J0=INT(39-.5*LEN(G2$)):PRINT TAB(J0);G2$`GoToNextLine ^(^

^)^: ` 7800 Z5=5:GOSUB 9030:J0=INT(39-.5*LEN(G2$)):PRINT TAB(J0);G2$`GoToNextLine ^(^

^)^: ` 7850 PRINT O1$:NEXT I:PRINT:GOTO 1990`GoToNextLine ^(^

^)^: ` 7850 PRINT O1$:NEXT I:PRINT:GOTO 1990`GoToNextLine ^(^

^)^: ` 7900 PRINT "   STATUS REPORT:":PRINT "   -------------":X$="":IF K9>1 THEN X$="S"`GoToNextLine ^(^

^)^: ` 7900 PRINT "   STATUS REPORT:":PRINT "   -------------":X$="":IF K9>1 THEN X$="S"`GoToNextLine ^(^

^)^: ` 7940 PRINT K9;"KLINGON";X$;" LEFT."`GoToNextLine ^(^

^)^: ` 7940 PRINT K9;"KLINGON";X$;" LEFT."`GoToNextLine ^(^

^)^: ` 7960 PRINT" MISSION MUST BE COMPLETED IN";.1*INT((T0+T9-T)*10);"STARDATES."`GoToNextLine ^(^

^)^: ` 7960 PRINT" MISSION MUST BE COMPLETED IN";.1*INT((T0+T9-T)*10);"STARDATES."`GoToNextLine ^(^

^)^: ` 7970 X$="S":IF B9<2 THEN X$="":IF B9<1 THEN 8010`GoToNextLine ^(^

^)^: ` 7970 X$="S":IF B9<2 THEN X$="":IF B9<1 THEN 8010`GoToNextLine ^(^

^)^: ` 7980 PRINT" THE FEDERATION IS MAINTAINING";B9;"STARBASE";X$;" IN THE GALAXY."`GoToNextLine ^(^

^)^: ` 7980 PRINT" THE FEDERATION IS MAINTAINING";B9;"STARBASE";X$;" IN THE GALAXY."`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 2330 PRINT"   LT. SULU: 'INCORRECT COURSE DATA, SIR!'":GOTO 1990`GoToNextLine ^(^

^)^: ` 6090 IF S<=0 THEN 6240`GoToNextLine ^(^

^)^: ` 8080 X$="":IF K3>1 THEN X$="S"`GoToNextLine ^(^

^)^: ` 8080 X$="":IF K3>1 THEN X$="S"`GoToNextLine ^(^

^)^: ` 8090 PRINT"FROM ENTERPRISE TO KLINGON BATTLE CRUSER";X$`GoToNextLine ^(^

^)^: ` 8090 PRINT"FROM ENTERPRISE TO KLINGON BATTLE CRUSER";X$`GoToNextLine ^(^

^)^: ` 8100 H8=0:FOR I=1 TO 3:IF K(I,3)<=0 THEN 8480`GoToNextLine ^(^

^)^: ` 8100 H8=0:FOR I=1 TO 3:IF K(I,3)<=0 THEN 8480`GoToNextLine ^(^

^)^: ` 8110 W1=K(I,1):X=K(I,2)`GoToNextLine ^(^

^)^: ` 8110 W1=K(I,1):X=K(I,2)`GoToNextLine ^(^

^)^: ` 8120 C1=S1:A=S2:GOTO 8220`GoToNextLine ^(^

^)^: ` 8120 C1=S1:A=S2:GOTO 8220`GoToNextLine ^(^

^)^: ` 130 PRINT "NOTE:  YOU MUST BE RUNNING 40K CP/M TO RUN STARTREK."`GoToNextLine ^(^

^)^: ` 8160 PRINT"YOU ARE AT QUADRANT ";Q1;CHR$(8);",";Q2;" SECTOR ";S1;CHR$(8);",";S2;CHR$(8);"."`GoToNextLine ^(^

^)^: ` 8160 PRINT"YOU ARE AT QUADRANT ";Q1;CHR$(8);",";Q2;" SECTOR ";S1;CHR$(8);",";S2;CHR$(8);"."`GoToNextLine ^(^

^)^: ` 8170 INPUT"PLEASE ENTER INITIAL COORDINATES (X,Y)";C1,A`GoToNextLine ^(^

^)^: ` 8170 INPUT"PLEASE ENTER INITIAL COORDINATES (X,Y)";C1,A`GoToNextLine ^(^

^)^: ` 8200 INPUT"FINAL COORDINATES (X,Y)";W1,X`GoToNextLine ^(^

^)^: ` 8200 INPUT"FINAL COORDINATES (X,Y)";W1,X`GoToNextLine ^(^

^)^: ` 8220 X=X-A:A=C1-W1:IF X<0 THEN 8350`GoToNextLine ^(^

^)^: ` 8220 X=X-A:A=C1-W1:IF X<0 THEN 8350`GoToNextLine ^(^

^)^: ` 1820 IF B3<1 THEN 1910`GoToNextLine ^(^

^)^: ` 4265 IF K3>0 THEN 4330`GoToNextLine ^(^

^)^: ` 8270 IF A=0 THEN C1=5:GOTO 8290`GoToNextLine ^(^

^)^: ` 8270 IF A=0 THEN C1=5:GOTO 8290`GoToNextLine ^(^

^)^: ` 8280 C1=1`GoToNextLine ^(^

^)^: ` 8280 C1=1`GoToNextLine ^(^

^)^: ` 8290 IF ABS(A)<=ABS(X)THEN 8330`GoToNextLine ^(^

^)^: ` 8290 IF ABS(A)<=ABS(X)THEN 8330`GoToNextLine ^(^

^)^: ` 8310 PRINT"DIRECTION =";C1+(((ABS(A)-ABS(X))+ABS(A))/ABS(A)):GOTO 8460`GoToNextLine ^(^

^)^: ` 8310 PRINT"DIRECTION =";C1+(((ABS(A)-ABS(X))+ABS(A))/ABS(A)):GOTO 8460`GoToNextLine ^(^

^)^: ` 8330 PRINT"DIRECTION =";C1+(ABS(A)/ABS(X)):GOTO 8460`GoToNextLine ^(^

^)^: ` 8330 PRINT"DIRECTION =";C1+(ABS(A)/ABS(X)):GOTO 8460`GoToNextLine ^(^

^)^: ` 8350 IF A>0 THEN C1=3:GOTO 8420`GoToNextLine ^(^

^)^: ` 8350 IF A>0 THEN C1=3:GOTO 8420`GoToNextLine ^(^

^)^: ` 8360 IF X<>0 THEN C1=5:GOTO 8290`GoToNextLine ^(^

^)^: ` 8360 IF X<>0 THEN C1=5:GOTO 8290`GoToNextLine ^(^

^)^: ` 8280 C1=1`GoToNextLine ^(^

^)^: ` 8420 IF ABS(A)>=ABS(X)THEN 8450`GoToNextLine ^(^

^)^: ` 8420 IF ABS(A)>=ABS(X)THEN 8450`GoToNextLine ^(^

^)^: ` 8430 PRINT"DIRECTION =";C1+(((ABS(X)-ABS(A))+ABS(X))/ABS(X)):GOTO 8460`GoToNextLine ^(^

^)^: ` 8430 PRINT"DIRECTION =";C1+(((ABS(X)-ABS(A))+ABS(X))/ABS(X)):GOTO 8460`GoToNextLine ^(^

^)^: ` 8450 PRINT"DIRECTION =";C1+(ABS(X)/ABS(A))`GoToNextLine ^(^

^)^: ` 8450 PRINT"DIRECTION =";C1+(ABS(X)/ABS(A))`GoToNextLine ^(^

^)^: ` 8460 PRINT"DISTANCE =";SQR(X^2+A^2):IF H8=1 THEN 1990`GoToNextLine ^(^

^)^: ` 8460 PRINT"DISTANCE =";SQR(X^2+A^2):IF H8=1 THEN 1990`GoToNextLine ^(^

^)^: ` 7721 NEXT J:GOTO 7850`GoToNextLine ^(^

^)^: ` 8500 IF B3<>0 THEN PRINT"FROM ENTERPRISE TO STARBASE:":W1=B4:X=B5:GOTO 8120`GoToNextLine ^(^

^)^: ` 8500 IF B3<>0 THEN PRINT"FROM ENTERPRISE TO STARBASE:":W1=B4:X=B5:GOTO 8120`GoToNextLine ^(^

^)^: ` 8510 PRINT"MR. SPOCK:  'SENSORS SHOW NO STARBASES IN THIS QUADRANT.'"";`GoToNextLine ^(^

^)^: ` 8510 PRINT"MR. SPOCK:  'SENSORS SHOW NO STARBASES IN THIS QUADRANT.'"";`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 8590 R1=FNR(1):R2=FNR(1):A$="   ":Z1=R1:Z2=R2:GOSUB 8830:IF Z3=0 THEN 8590`GoToNextLine ^(^

^)^: ` 8590 R1=FNR(1):R2=FNR(1):A$="   ":Z1=R1:Z2=R2:GOSUB 8830:IF Z3=0 THEN 8590`GoToNextLine ^(^

^)^: ` 3980 RETURN`GoToNextLine ^(^

^)^: ` 8670 S8=INT(Z2-.5)*3+INT(Z1-.5)*24+1`GoToNextLine ^(^

^)^: ` 8670 S8=INT(Z2-.5)*3+INT(Z1-.5)*24+1`GoToNextLine ^(^

^)^: ` 8675 IF LEN(A$)<>3 THEN PRINT"ERROR":STOP`GoToNextLine ^(^

^)^: ` 8675 IF LEN(A$)<>3 THEN PRINT"ERROR":STOP`GoToNextLine ^(^

^)^: ` 8680 IF S8=1 THEN Q$=A$+RIGHT$(Q$,189):RETURN`GoToNextLine ^(^

^)^: ` 8680 IF S8=1 THEN Q$=A$+RIGHT$(Q$,189):RETURN`GoToNextLine ^(^

^)^: ` 8690 IF S8=190 THEN Q$=LEFT$(Q$,189)+A$:RETURN`GoToNextLine ^(^

^)^: ` 8690 IF S8=190 THEN Q$=LEFT$(Q$,189)+A$:RETURN`GoToNextLine ^(^

^)^: ` 8700 Q$=LEFT$(Q$,S8-1)+A$+RIGHT$(Q$,190-S8):RETURN`GoToNextLine ^(^

^)^: ` 8700 Q$=LEFT$(Q$,S8-1)+A$+RIGHT$(Q$,190-S8):RETURN`GoToNextLine ^(^

^)^: ` 6830 ON I GOTO 6850,6900,6960,7020,7070,7120,7180,7240`GoToNextLine ^(^

^)^: ` 8792 G2$="WARP ENGINES":RETURN`GoToNextLine ^(^

^)^: ` 8792 G2$="WARP ENGINES":RETURN`GoToNextLine ^(^

^)^: ` 8792 G2$="WARP ENGINES":RETURN`GoToNextLine ^(^

^)^: ` 8792 G2$="WARP ENGINES":RETURN`GoToNextLine ^(^

^)^: ` 8792 G2$="WARP ENGINES":RETURN`GoToNextLine ^(^

^)^: ` 8792 G2$="WARP ENGINES":RETURN`GoToNextLine ^(^

^)^: ` 8792 G2$="WARP ENGINES":RETURN`GoToNextLine ^(^

^)^: ` 8792 G2$="WARP ENGINES":RETURN`GoToNextLine ^(^

^)^: ` 8792 G2$="WARP ENGINES":RETURN`GoToNextLine ^(^

^)^: ` 8830 Z1=INT(Z1+.5):Z2=INT(Z2+.5):S8=(Z2-1)*3+(Z1-1)*24+1:Z3=0`GoToNextLine ^(^

^)^: ` 8830 Z1=INT(Z1+.5):Z2=INT(Z2+.5):S8=(Z2-1)*3+(Z1-1)*24+1:Z3=0`GoToNextLine ^(^

^)^: ` 8890 IF MID$(Q$,S8,3)<>A$THEN RETURN`GoToNextLine ^(^

^)^: ` 8890 IF MID$(Q$,S8,3)<>A$THEN RETURN`GoToNextLine ^(^

^)^: ` 8900 Z3=1:RETURN`GoToNextLine ^(^

^)^: ` 8900 Z3=1:RETURN`GoToNextLine ^(^

^)^: ` 9030 IF Z5<=4 THEN ON Z4 GOTO 9040,9050,9060,9070,9080,9090,9100,9110`GoToNextLine ^(^

^)^: ` 9030 IF Z5<=4 THEN ON Z4 GOTO 9040,9050,9060,9070,9080,9090,9100,9110`GoToNextLine ^(^

^)^: ` 2570 GOTO 1990`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 6830 ON I GOTO 6850,6900,6960,7020,7070,7120,7180,7240`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 9040 G2$="ANTARES":GOTO 9210`GoToNextLine ^(^

^)^: ` 270 Z$="                         "`GoToNextLine ^(^

^)^: ` 9210 IF G5<>1 THEN ON Z5 GOTO 9230,9240,9250,9260,9230,9240,9250,9260`GoToNextLine ^(^

^)^: ` 9210 IF G5<>1 THEN ON Z5 GOTO 9230,9240,9250,9260,9230,9240,9250,9260`GoToNextLine ^(^

^)^: ` 3980 RETURN`GoToNextLine ^(^

^)^: ` 9230 G2$=G2$+" I":RETURN`GoToNextLine ^(^

^)^: ` 9230 G2$=G2$+" I":RETURN`GoToNextLine ^(^

^)^: ` 9230 G2$=G2$+" I":RETURN`GoToNextLine ^(^

^)^: ` 9230 G2$=G2$+" I":RETURN`GoToNextLine ^(^

^)^: ` 9230 G2$=G2$+" I":RETURN`GoToNextLine ^(^

^)^: ` 1240 END`GoToNextLine ^(^

^)^: ` // Copyright 2012 Rui Ueyama. Released under the MIT license.`GoToNextLine ^(^

^)^: ` // Copyright 2012 Rui Ueyama. Released under the MIT license.`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * This implements Dave Prosser's C Preprocessing algorithm, described`GoToNextLine ^(^

^)^: `  * This implements Dave Prosser's C Preprocessing algorithm, described`GoToNextLine ^(^

^)^: `  * in this document: https://github.com/rui314/8cc/wiki/cpp.algo.pdf`GoToNextLine ^(^

^)^: `  * in this document: https://github.com/rui314/8cc/wiki/cpp.algo.pdf`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include <string.h>`GoToNextLine ^(^

^)^: ` #include <string.h>`GoToNextLine ^(^

^)^: ` #include <time.h>`GoToNextLine ^(^

^)^: ` #include <time.h>`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include "8cc.h"`GoToNextLine ^(^

^)^: ` #include "8cc.h"`GoToNextLine ^(^

^)^: ` static Map *macros = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *macros = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *once = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *once = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *keywords = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *keywords = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *include_guard = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *include_guard = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Vector *cond_incl_stack = &EMPTY_VECTOR;`GoToNextLine ^(^

^)^: ` static Vector *cond_incl_stack = &EMPTY_VECTOR;`GoToNextLine ^(^

^)^: ` static Vector *std_include_path = &EMPTY_VECTOR;`GoToNextLine ^(^

^)^: ` static Vector *std_include_path = &EMPTY_VECTOR;`GoToNextLine ^(^

^)^: ` static struct tm now;`GoToNextLine ^(^

^)^: ` static struct tm now;`GoToNextLine ^(^

^)^: ` static Token *cpp_token_zero = &(Token){ .kind = TNUMBER, .sval = "0" };`GoToNextLine ^(^

^)^: ` static Token *cpp_token_zero = &(Token){ .kind = TNUMBER, .sval = "0" };`GoToNextLine ^(^

^)^: ` static Token *cpp_token_one = &(Token){ .kind = TNUMBER, .sval = "1" };`GoToNextLine ^(^

^)^: ` static Token *cpp_token_one = &(Token){ .kind = TNUMBER, .sval = "1" };`GoToNextLine ^(^

^)^: ` typedef void SpecialMacroHandler(Token *tok);`GoToNextLine ^(^

^)^: ` typedef void SpecialMacroHandler(Token *tok);`GoToNextLine ^(^

^)^: ` typedef enum { IN_THEN, IN_ELIF, IN_ELSE } CondInclCtx;`GoToNextLine ^(^

^)^: ` typedef enum { IN_THEN, IN_ELIF, IN_ELSE } CondInclCtx;`GoToNextLine ^(^

^)^: ` typedef enum { IN_THEN, IN_ELIF, IN_ELSE } CondInclCtx;`GoToNextLine ^(^

^)^: ` typedef struct {`GoToNextLine ^(^

^)^: ` typedef struct {`GoToNextLine ^(^

^)^: `     CondInclCtx ctx;`GoToNextLine ^(^

^)^: `     CondInclCtx ctx;`GoToNextLine ^(^

^)^: `     char *include_guard;`GoToNextLine ^(^

^)^: `     char *include_guard;`GoToNextLine ^(^

^)^: `     File *file;`GoToNextLine ^(^

^)^: `     File *file;`GoToNextLine ^(^

^)^: `     bool wastrue;`GoToNextLine ^(^

^)^: `     bool wastrue;`GoToNextLine ^(^

^)^: ` } CondIncl;`GoToNextLine ^(^

^)^: ` } CondIncl;`GoToNextLine ^(^

^)^: ` typedef struct {`GoToNextLine ^(^

^)^: `     CondInclCtx ctx;`GoToNextLine ^(^

^)^: `     int nargs;`GoToNextLine ^(^

^)^: `     int nargs;`GoToNextLine ^(^

^)^: `     Vector *body;`GoToNextLine ^(^

^)^: `     Vector *body;`GoToNextLine ^(^

^)^: `     bool wastrue;`GoToNextLine ^(^

^)^: `     SpecialMacroHandler *fn;`GoToNextLine ^(^

^)^: `     SpecialMacroHandler *fn;`GoToNextLine ^(^

^)^: ` } Macro;`GoToNextLine ^(^

^)^: ` } Macro;`GoToNextLine ^(^

^)^: ` static Macro *make_obj_macro(Vector *body);`GoToNextLine ^(^

^)^: ` static Macro *make_obj_macro(Vector *body);`GoToNextLine ^(^

^)^: ` static Macro *make_func_macro(Vector *body, int nargs, bool is_varg);`GoToNextLine ^(^

^)^: ` static Macro *make_func_macro(Vector *body, int nargs, bool is_varg);`GoToNextLine ^(^

^)^: ` static Macro *make_special_macro(SpecialMacroHandler *fn);`GoToNextLine ^(^

^)^: ` static Macro *make_special_macro(SpecialMacroHandler *fn);`GoToNextLine ^(^

^)^: ` static void define_obj_macro(char *name, Token *value);`GoToNextLine ^(^

^)^: ` static void define_obj_macro(char *name, Token *value);`GoToNextLine ^(^

^)^: ` static void read_directive(Token *hash);`GoToNextLine ^(^

^)^: ` static void read_directive(Token *hash);`GoToNextLine ^(^

^)^: ` static Token *read_expand(void);`GoToNextLine ^(^

^)^: ` static Token *read_expand(void);`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Constructors`GoToNextLine ^(^

^)^: `  * Constructors`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static CondIncl *make_cond_incl(bool wastrue) {`GoToNextLine ^(^

^)^: ` static CondIncl *make_cond_incl(bool wastrue) {`GoToNextLine ^(^

^)^: `     CondIncl *r = calloc(1, sizeof(CondIncl));`GoToNextLine ^(^

^)^: `     CondIncl *r = calloc(1, sizeof(CondIncl));`GoToNextLine ^(^

^)^: `     r->ctx = IN_THEN;`GoToNextLine ^(^

^)^: `     r->ctx = IN_THEN;`GoToNextLine ^(^

^)^: `     r->wastrue = wastrue;`GoToNextLine ^(^

^)^: `     r->wastrue = wastrue;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Macro *make_macro(Macro *tmpl) {`GoToNextLine ^(^

^)^: ` static Macro *make_macro(Macro *tmpl) {`GoToNextLine ^(^

^)^: `     Macro *r = malloc(sizeof(Macro));`GoToNextLine ^(^

^)^: `     Macro *r = malloc(sizeof(Macro));`GoToNextLine ^(^

^)^: `     *r = *tmpl;`GoToNextLine ^(^

^)^: `     *r = *tmpl;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Macro *make_obj_macro(Vector *body) {`GoToNextLine ^(^

^)^: ` static Macro *make_obj_macro(Vector *body) {`GoToNextLine ^(^

^)^: `     return make_macro(&(Macro){ MACRO_OBJ, .body = body });`GoToNextLine ^(^

^)^: `     return make_macro(&(Macro){ MACRO_OBJ, .body = body });`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Macro *make_func_macro(Vector *body, int nargs, bool is_varg) {`GoToNextLine ^(^

^)^: ` static Macro *make_func_macro(Vector *body, int nargs, bool is_varg) {`GoToNextLine ^(^

^)^: `     return make_macro(&(Macro){`GoToNextLine ^(^

^)^: `     return make_macro(&(Macro){`GoToNextLine ^(^

^)^: `             MACRO_FUNC, .nargs = nargs, .body = body, .is_varg = is_varg });`GoToNextLine ^(^

^)^: `             MACRO_FUNC, .nargs = nargs, .body = body, .is_varg = is_varg });`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Macro *make_special_macro(SpecialMacroHandler *fn) {`GoToNextLine ^(^

^)^: ` static Macro *make_special_macro(SpecialMacroHandler *fn) {`GoToNextLine ^(^

^)^: `     return make_macro(&(Macro){ MACRO_SPECIAL, .fn = fn });`GoToNextLine ^(^

^)^: `     return make_macro(&(Macro){ MACRO_SPECIAL, .fn = fn });`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *make_macro_token(int position, bool is_vararg) {`GoToNextLine ^(^

^)^: ` static Token *make_macro_token(int position, bool is_vararg) {`GoToNextLine ^(^

^)^: `     Token *r = malloc(sizeof(Token));`GoToNextLine ^(^

^)^: `     Token *r = malloc(sizeof(Token));`GoToNextLine ^(^

^)^: `     r->kind = TMACRO_PARAM;`GoToNextLine ^(^

^)^: `     r->kind = TMACRO_PARAM;`GoToNextLine ^(^

^)^: `     r->is_vararg = is_vararg;`GoToNextLine ^(^

^)^: `     r->is_vararg = is_vararg;`GoToNextLine ^(^

^)^: `     r->hideset = NULL;`GoToNextLine ^(^

^)^: `     r->hideset = NULL;`GoToNextLine ^(^

^)^: `     r->position = position;`GoToNextLine ^(^

^)^: `     r->position = position;`GoToNextLine ^(^

^)^: `     r->space = false;`GoToNextLine ^(^

^)^: `     r->space = false;`GoToNextLine ^(^

^)^: `     r->bol = false;`GoToNextLine ^(^

^)^: `     r->bol = false;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *copy_token(Token *tok) {`GoToNextLine ^(^

^)^: ` static Token *copy_token(Token *tok) {`GoToNextLine ^(^

^)^: `     Token *r = malloc(sizeof(Token));`GoToNextLine ^(^

^)^: `     *r = *tok;`GoToNextLine ^(^

^)^: `     *r = *tok;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void expect(char id) {`GoToNextLine ^(^

^)^: ` static void expect(char id) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (!is_keyword(tok, id))`GoToNextLine ^(^

^)^: `     if (!is_keyword(tok, id))`GoToNextLine ^(^

^)^: `         errort(tok, "%c expected, but got %s", id, tok2s(tok));`GoToNextLine ^(^

^)^: `         errort(tok, "%c expected, but got %s", id, tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Utility functions`GoToNextLine ^(^

^)^: `  * Utility functions`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` bool is_ident(Token *tok, char *s) {`GoToNextLine ^(^

^)^: ` bool is_ident(Token *tok, char *s) {`GoToNextLine ^(^

^)^: `     return tok->kind == TIDENT && !strcmp(tok->sval, s);`GoToNextLine ^(^

^)^: `     return tok->kind == TIDENT && !strcmp(tok->sval, s);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool next(int id) {`GoToNextLine ^(^

^)^: ` static bool next(int id) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (is_keyword(tok, id))`GoToNextLine ^(^

^)^: `     if (is_keyword(tok, id))`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `     return false;`GoToNextLine ^(^

^)^: `     return false;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void propagate_space(Vector *tokens, Token *tmpl) {`GoToNextLine ^(^

^)^: ` static void propagate_space(Vector *tokens, Token *tmpl) {`GoToNextLine ^(^

^)^: `     if (vec_len(tokens) == 0)`GoToNextLine ^(^

^)^: `     if (vec_len(tokens) == 0)`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `     Token *tok = copy_token(vec_head(tokens));`GoToNextLine ^(^

^)^: `     Token *tok = copy_token(vec_head(tokens));`GoToNextLine ^(^

^)^: `     tok->space = tmpl->space;`GoToNextLine ^(^

^)^: `     tok->space = tmpl->space;`GoToNextLine ^(^

^)^: `     vec_set(tokens, 0, tok);`GoToNextLine ^(^

^)^: `     vec_set(tokens, 0, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Macro expander`GoToNextLine ^(^

^)^: `  * Macro expander`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static Token *read_ident() {`GoToNextLine ^(^

^)^: ` static Token *read_ident() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` void expect_newline() {`GoToNextLine ^(^

^)^: ` void expect_newline() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *read_one_arg(Token *ident, bool *end, bool readall) {`GoToNextLine ^(^

^)^: ` static Vector *read_one_arg(Token *ident, bool *end, bool readall) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     int level = 0;`GoToNextLine ^(^

^)^: `     int level = 0;`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             errort(ident, "unterminated macro argument list");`GoToNextLine ^(^

^)^: `             errort(ident, "unterminated macro argument list");`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: `         if (tok->bol && is_keyword(tok, '#')) {`GoToNextLine ^(^

^)^: `         if (tok->bol && is_keyword(tok, '#')) {`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (level == 0 && is_keyword(tok, ')')) {`GoToNextLine ^(^

^)^: `         if (level == 0 && is_keyword(tok, ')')) {`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `             *end = true;`GoToNextLine ^(^

^)^: `             *end = true;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (level == 0 && is_keyword(tok, ',') && !readall)`GoToNextLine ^(^

^)^: `         if (level == 0 && is_keyword(tok, ',') && !readall)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, '('))`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, '('))`GoToNextLine ^(^

^)^: `             level++;`GoToNextLine ^(^

^)^: `             level++;`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, '('))`GoToNextLine ^(^

^)^: `             level--;`GoToNextLine ^(^

^)^: `             level--;`GoToNextLine ^(^

^)^: `         // C11 6.10.3p10: Within the macro argument list,`GoToNextLine ^(^

^)^: `         // C11 6.10.3p10: Within the macro argument list,`GoToNextLine ^(^

^)^: `         // newline is considered a normal whitespace character.`GoToNextLine ^(^

^)^: `         // newline is considered a normal whitespace character.`GoToNextLine ^(^

^)^: `         // I don't know why the standard specifies such a minor detail,`GoToNextLine ^(^

^)^: `         // I don't know why the standard specifies such a minor detail,`GoToNextLine ^(^

^)^: `         // but the difference of newline and space is observable`GoToNextLine ^(^

^)^: `         // but the difference of newline and space is observable`GoToNextLine ^(^

^)^: `         // if you stringize tokens using #.`GoToNextLine ^(^

^)^: `         // if you stringize tokens using #.`GoToNextLine ^(^

^)^: `         if (tok->bol) {`GoToNextLine ^(^

^)^: `         if (tok->bol) {`GoToNextLine ^(^

^)^: `             tok = copy_token(tok);`GoToNextLine ^(^

^)^: `             tok = copy_token(tok);`GoToNextLine ^(^

^)^: `     r->bol = false;`GoToNextLine ^(^

^)^: `             tok->space = true;`GoToNextLine ^(^

^)^: `             tok->space = true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *do_read_args(Token *ident, Macro *macro) {`GoToNextLine ^(^

^)^: ` static Vector *do_read_args(Token *ident, Macro *macro) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     bool end = false;`GoToNextLine ^(^

^)^: `     bool end = false;`GoToNextLine ^(^

^)^: `     while (!end) {`GoToNextLine ^(^

^)^: `     while (!end) {`GoToNextLine ^(^

^)^: `         bool in_ellipsis = (macro->is_varg && vec_len(r) + 1 == macro->nargs);`GoToNextLine ^(^

^)^: `         bool in_ellipsis = (macro->is_varg && vec_len(r) + 1 == macro->nargs);`GoToNextLine ^(^

^)^: `         vec_push(r, read_one_arg(ident, &end, in_ellipsis));`GoToNextLine ^(^

^)^: `         vec_push(r, read_one_arg(ident, &end, in_ellipsis));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (macro->is_varg && vec_len(r) == macro->nargs - 1)`GoToNextLine ^(^

^)^: `     if (macro->is_varg && vec_len(r) == macro->nargs - 1)`GoToNextLine ^(^

^)^: `         vec_push(r, make_vector());`GoToNextLine ^(^

^)^: `         vec_push(r, make_vector());`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *read_args(Token *tok, Macro *macro) {`GoToNextLine ^(^

^)^: ` static Vector *read_args(Token *tok, Macro *macro) {`GoToNextLine ^(^

^)^: `     if (macro->nargs == 0 && is_keyword(peek_token(), ')')) {`GoToNextLine ^(^

^)^: `     if (macro->nargs == 0 && is_keyword(peek_token(), ')')) {`GoToNextLine ^(^

^)^: `         // If a macro M has no parameter, argument list of M()`GoToNextLine ^(^

^)^: `         // If a macro M has no parameter, argument list of M()`GoToNextLine ^(^

^)^: `         // is an empty list. If it has one parameter,`GoToNextLine ^(^

^)^: `         // is an empty list. If it has one parameter,`GoToNextLine ^(^

^)^: `         // argument list of M() is a list containing an empty list.`GoToNextLine ^(^

^)^: `         // argument list of M() is a list containing an empty list.`GoToNextLine ^(^

^)^: `         return make_vector();`GoToNextLine ^(^

^)^: `         return make_vector();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     Vector *args = do_read_args(tok, macro);`GoToNextLine ^(^

^)^: `     Vector *args = do_read_args(tok, macro);`GoToNextLine ^(^

^)^: `     if (vec_len(args) != macro->nargs)`GoToNextLine ^(^

^)^: `     if (vec_len(args) != macro->nargs)`GoToNextLine ^(^

^)^: `         errort(tok, "macro argument number does not match");`GoToNextLine ^(^

^)^: `         errort(tok, "macro argument number does not match");`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *add_hide_set(Vector *tokens, Set *hideset) {`GoToNextLine ^(^

^)^: ` static Vector *add_hide_set(Vector *tokens, Set *hideset) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(tokens); i++) {`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(tokens); i++) {`GoToNextLine ^(^

^)^: `         Token *t = copy_token(vec_get(tokens, i));`GoToNextLine ^(^

^)^: `         Token *t = copy_token(vec_get(tokens, i));`GoToNextLine ^(^

^)^: `         t->hideset = set_union(t->hideset, hideset);`GoToNextLine ^(^

^)^: `         t->hideset = set_union(t->hideset, hideset);`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *glue_tokens(Token *t, Token *u) {`GoToNextLine ^(^

^)^: ` static Token *glue_tokens(Token *t, Token *u) {`GoToNextLine ^(^

^)^: `     Buffer *b = make_buffer();`GoToNextLine ^(^

^)^: `     Buffer *b = make_buffer();`GoToNextLine ^(^

^)^: `     buf_printf(b, "%s", tok2s(t));`GoToNextLine ^(^

^)^: `     buf_printf(b, "%s", tok2s(t));`GoToNextLine ^(^

^)^: `     buf_printf(b, "%s", tok2s(u));`GoToNextLine ^(^

^)^: `     buf_printf(b, "%s", tok2s(u));`GoToNextLine ^(^

^)^: `     Token *r = lex_string(buf_body(b));`GoToNextLine ^(^

^)^: `     Token *r = lex_string(buf_body(b));`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void glue_push(Vector *tokens, Token *tok) {`GoToNextLine ^(^

^)^: ` static void glue_push(Vector *tokens, Token *tok) {`GoToNextLine ^(^

^)^: `     Token *last = vec_pop(tokens);`GoToNextLine ^(^

^)^: `     Token *last = vec_pop(tokens);`GoToNextLine ^(^

^)^: `     vec_push(tokens, glue_tokens(last, tok));`GoToNextLine ^(^

^)^: `     vec_push(tokens, glue_tokens(last, tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *stringize(Token *tmpl, Vector *args) {`GoToNextLine ^(^

^)^: ` static Token *stringize(Token *tmpl, Vector *args) {`GoToNextLine ^(^

^)^: `     Buffer *b = make_buffer();`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(args); i++) {`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(args); i++) {`GoToNextLine ^(^

^)^: `         Token *tok = vec_get(args, i);`GoToNextLine ^(^

^)^: `         Token *tok = vec_get(args, i);`GoToNextLine ^(^

^)^: `         if (buf_len(b) && tok->space)`GoToNextLine ^(^

^)^: `         if (buf_len(b) && tok->space)`GoToNextLine ^(^

^)^: `             buf_printf(b, " ");`GoToNextLine ^(^

^)^: `             buf_printf(b, " ");`GoToNextLine ^(^

^)^: `         buf_printf(b, "%s", tok2s(tok));`GoToNextLine ^(^

^)^: `         buf_printf(b, "%s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     buf_write(b, '\0');`GoToNextLine ^(^

^)^: `     buf_write(b, '\0');`GoToNextLine ^(^

^)^: `     Token *r = copy_token(tmpl);`GoToNextLine ^(^

^)^: `     Token *r = copy_token(tmpl);`GoToNextLine ^(^

^)^: `     r->kind = TMACRO_PARAM;`GoToNextLine ^(^

^)^: `     r->sval = buf_body(b);`GoToNextLine ^(^

^)^: `     r->sval = buf_body(b);`GoToNextLine ^(^

^)^: `     r->slen = buf_len(b);`GoToNextLine ^(^

^)^: `     r->slen = buf_len(b);`GoToNextLine ^(^

^)^: `     r->enc = ENC_NONE;`GoToNextLine ^(^

^)^: `     r->enc = ENC_NONE;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *expand_all(Vector *tokens, Token *tmpl) {`GoToNextLine ^(^

^)^: ` static Vector *expand_all(Vector *tokens, Token *tmpl) {`GoToNextLine ^(^

^)^: `     token_buffer_stash(vec_reverse(tokens));`GoToNextLine ^(^

^)^: `     token_buffer_stash(vec_reverse(tokens));`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             break;`GoToNextLine ^(^

^)^: `             break;`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *subst(Macro *macro, Vector *args, Set *hideset) {`GoToNextLine ^(^

^)^: ` static Vector *subst(Macro *macro, Vector *args, Set *hideset) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     int len = vec_len(macro->body);`GoToNextLine ^(^

^)^: `     int len = vec_len(macro->body);`GoToNextLine ^(^

^)^: `     for (int i = 0; i < len; i++) {`GoToNextLine ^(^

^)^: `     for (int i = 0; i < len; i++) {`GoToNextLine ^(^

^)^: `         Token *t0 = vec_get(macro->body, i);`GoToNextLine ^(^

^)^: `         Token *t0 = vec_get(macro->body, i);`GoToNextLine ^(^

^)^: `         Token *t1 = (i == len - 1) ? NULL : vec_get(macro->body, i + 1);`GoToNextLine ^(^

^)^: `         Token *t1 = (i == len - 1) ? NULL : vec_get(macro->body, i + 1);`GoToNextLine ^(^

^)^: `         bool t0_param = (t0->kind == TMACRO_PARAM);`GoToNextLine ^(^

^)^: `         bool t0_param = (t0->kind == TMACRO_PARAM);`GoToNextLine ^(^

^)^: `         bool t1_param = (t1 && t1->kind == TMACRO_PARAM);`GoToNextLine ^(^

^)^: `         bool t1_param = (t1 && t1->kind == TMACRO_PARAM);`GoToNextLine ^(^

^)^: `         if (is_keyword(t0, '#') && t1_param) {`GoToNextLine ^(^

^)^: `         if (is_keyword(t0, '#') && t1_param) {`GoToNextLine ^(^

^)^: `             vec_push(r, stringize(t0, vec_get(args, t1->position)));`GoToNextLine ^(^

^)^: `             vec_push(r, stringize(t0, vec_get(args, t1->position)));`GoToNextLine ^(^

^)^: `             i++;`GoToNextLine ^(^

^)^: `             i++;`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (is_keyword(t0, KHASHHASH) && t1_param) {`GoToNextLine ^(^

^)^: `         if (is_keyword(t0, KHASHHASH) && t1_param) {`GoToNextLine ^(^

^)^: `             Vector *arg = vec_get(args, t1->position);`GoToNextLine ^(^

^)^: `             Vector *arg = vec_get(args, t1->position);`GoToNextLine ^(^

^)^: `             // [GNU] [,##__VA_ARG__] is expanded to the empty token sequence`GoToNextLine ^(^

^)^: `             // [GNU] [,##__VA_ARG__] is expanded to the empty token sequence`GoToNextLine ^(^

^)^: `             // if __VA_ARG__ is empty. Otherwise it's expanded to`GoToNextLine ^(^

^)^: `             // if __VA_ARG__ is empty. Otherwise it's expanded to`GoToNextLine ^(^

^)^: `             // [,<tokens in __VA_ARG__>].`GoToNextLine ^(^

^)^: `             // [,<tokens in __VA_ARG__>].`GoToNextLine ^(^

^)^: `             if (t1->is_vararg && vec_len(r) > 0 && is_keyword(vec_tail(r), ',')) {`GoToNextLine ^(^

^)^: `             if (t1->is_vararg && vec_len(r) > 0 && is_keyword(vec_tail(r), ',')) {`GoToNextLine ^(^

^)^: `                 if (vec_len(arg) > 0)`GoToNextLine ^(^

^)^: `                 if (vec_len(arg) > 0)`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `                 else`GoToNextLine ^(^

^)^: `                 else`GoToNextLine ^(^

^)^: `                     vec_pop(r);`GoToNextLine ^(^

^)^: `                     vec_pop(r);`GoToNextLine ^(^

^)^: `             } else if (vec_len(arg) > 0) {`GoToNextLine ^(^

^)^: `             } else if (vec_len(arg) > 0) {`GoToNextLine ^(^

^)^: `                 glue_push(r, vec_head(arg));`GoToNextLine ^(^

^)^: `                 glue_push(r, vec_head(arg));`GoToNextLine ^(^

^)^: `                 for (int i = 1; i < vec_len(arg); i++)`GoToNextLine ^(^

^)^: `                 for (int i = 1; i < vec_len(arg); i++)`GoToNextLine ^(^

^)^: `                     vec_push(r, vec_get(arg, i));`GoToNextLine ^(^

^)^: `                     vec_push(r, vec_get(arg, i));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `             i++;`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (is_keyword(t0, KHASHHASH) && t1_param) {`GoToNextLine ^(^

^)^: `             hideset = t1->hideset;`GoToNextLine ^(^

^)^: `             hideset = t1->hideset;`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `             i++;`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (t0_param && t1 && is_keyword(t1, KHASHHASH)) {`GoToNextLine ^(^

^)^: `         if (t0_param && t1 && is_keyword(t1, KHASHHASH)) {`GoToNextLine ^(^

^)^: `             hideset = t1->hideset;`GoToNextLine ^(^

^)^: `             Vector *arg = vec_get(args, t1->position);`GoToNextLine ^(^

^)^: `             if (vec_len(arg) == 0)`GoToNextLine ^(^

^)^: `             if (vec_len(arg) == 0)`GoToNextLine ^(^

^)^: `             i++;`GoToNextLine ^(^

^)^: `                 else`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (t0_param) {`GoToNextLine ^(^

^)^: `         if (t0_param) {`GoToNextLine ^(^

^)^: `             Vector *arg = vec_get(args, t1->position);`GoToNextLine ^(^

^)^: `                     vec_push(r, vec_get(arg, i));`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     return add_hide_set(r, hideset);`GoToNextLine ^(^

^)^: `     return add_hide_set(r, hideset);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void unget_all(Vector *tokens) {`GoToNextLine ^(^

^)^: ` static void unget_all(Vector *tokens) {`GoToNextLine ^(^

^)^: `     for (int i = vec_len(tokens) - 1; i >= 0; i--)`GoToNextLine ^(^

^)^: `     for (int i = vec_len(tokens) - 1; i >= 0; i--)`GoToNextLine ^(^

^)^: `         unget_token(vec_get(tokens, i));`GoToNextLine ^(^

^)^: `         unget_token(vec_get(tokens, i));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` // This is "expand" function in the Dave Prosser's document.`GoToNextLine ^(^

^)^: ` // This is "expand" function in the Dave Prosser's document.`GoToNextLine ^(^

^)^: ` static Token *read_expand_newline() {`GoToNextLine ^(^

^)^: ` static Token *read_expand_newline() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     char *name = tok->sval;`GoToNextLine ^(^

^)^: `     char *name = tok->sval;`GoToNextLine ^(^

^)^: `     Macro *macro = map_get(macros, name);`GoToNextLine ^(^

^)^: `     Macro *macro = map_get(macros, name);`GoToNextLine ^(^

^)^: `     if (!macro || set_has(tok->hideset, name))`GoToNextLine ^(^

^)^: `     if (!macro || set_has(tok->hideset, name))`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     switch (macro->kind) {`GoToNextLine ^(^

^)^: `     switch (macro->kind) {`GoToNextLine ^(^

^)^: `     case MACRO_OBJ: {`GoToNextLine ^(^

^)^: `     case MACRO_OBJ: {`GoToNextLine ^(^

^)^: `         Set *hideset = set_add(tok->hideset, name);`GoToNextLine ^(^

^)^: `         Set *hideset = set_add(tok->hideset, name);`GoToNextLine ^(^

^)^: `         Vector *tokens = subst(macro, NULL, hideset);`GoToNextLine ^(^

^)^: `         Vector *tokens = subst(macro, NULL, hideset);`GoToNextLine ^(^

^)^: `         propagate_space(tokens, tok);`GoToNextLine ^(^

^)^: `         propagate_space(tokens, tok);`GoToNextLine ^(^

^)^: `         unget_all(tokens);`GoToNextLine ^(^

^)^: `         unget_all(tokens);`GoToNextLine ^(^

^)^: `         return make_vector();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     case MACRO_OBJ: {`GoToNextLine ^(^

^)^: `         if (!next('('))`GoToNextLine ^(^

^)^: `         if (!next('('))`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     Vector *args = do_read_args(tok, macro);`GoToNextLine ^(^

^)^: `         Token *rparen = peek_token();`GoToNextLine ^(^

^)^: `         Token *rparen = peek_token();`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: `         Set *hideset = set_add(set_intersection(tok->hideset, rparen->hideset), name);`GoToNextLine ^(^

^)^: `         Set *hideset = set_add(set_intersection(tok->hideset, rparen->hideset), name);`GoToNextLine ^(^

^)^: `         Vector *tokens = subst(macro, args, hideset);`GoToNextLine ^(^

^)^: `         Vector *tokens = subst(macro, args, hideset);`GoToNextLine ^(^

^)^: `         propagate_space(tokens, tok);`GoToNextLine ^(^

^)^: `         unget_all(tokens);`GoToNextLine ^(^

^)^: `         return make_vector();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     case MACRO_SPECIAL:`GoToNextLine ^(^

^)^: `     case MACRO_SPECIAL:`GoToNextLine ^(^

^)^: `         macro->fn(tok);`GoToNextLine ^(^

^)^: `         macro->fn(tok);`GoToNextLine ^(^

^)^: `         return make_vector();`GoToNextLine ^(^

^)^: `     default:`GoToNextLine ^(^

^)^: `     default:`GoToNextLine ^(^

^)^: `         error("internal error");`GoToNextLine ^(^

^)^: `         error("internal error");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *read_expand() {`GoToNextLine ^(^

^)^: ` static Token *read_expand() {`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool read_funclike_macro_params(Token *name, Map *param) {`GoToNextLine ^(^

^)^: ` static bool read_funclike_macro_params(Token *name, Map *param) {`GoToNextLine ^(^

^)^: `     int pos = 0;`GoToNextLine ^(^

^)^: `     int pos = 0;`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, '('))`GoToNextLine ^(^

^)^: `     return false;`GoToNextLine ^(^

^)^: `         if (pos) {`GoToNextLine ^(^

^)^: `         if (pos) {`GoToNextLine ^(^

^)^: `             if (!is_keyword(tok, ','))`GoToNextLine ^(^

^)^: `             if (!is_keyword(tok, ','))`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             errort(name, "missing ')' in macro parameter list");`GoToNextLine ^(^

^)^: `             errort(name, "missing ')' in macro parameter list");`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, KELLIPSIS)) {`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, KELLIPSIS)) {`GoToNextLine ^(^

^)^: `             map_put(param, "__VA_ARGS__", make_macro_token(pos++, true));`GoToNextLine ^(^

^)^: `             map_put(param, "__VA_ARGS__", make_macro_token(pos++, true));`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `         char *arg = tok->sval;`GoToNextLine ^(^

^)^: `         char *arg = tok->sval;`GoToNextLine ^(^

^)^: `         if (next(KELLIPSIS)) {`GoToNextLine ^(^

^)^: `         if (next(KELLIPSIS)) {`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: `             map_put(param, arg, make_macro_token(pos++, true));`GoToNextLine ^(^

^)^: `             map_put(param, arg, make_macro_token(pos++, true));`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         map_put(param, arg, make_macro_token(pos++, false));`GoToNextLine ^(^

^)^: `         map_put(param, arg, make_macro_token(pos++, false));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void hashhash_check(Vector *v) {`GoToNextLine ^(^

^)^: ` static void hashhash_check(Vector *v) {`GoToNextLine ^(^

^)^: `     if (vec_len(v) == 0)`GoToNextLine ^(^

^)^: `     if (vec_len(v) == 0)`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `     if (is_keyword(vec_head(v), KHASHHASH))`GoToNextLine ^(^

^)^: `     if (is_keyword(vec_head(v), KHASHHASH))`GoToNextLine ^(^

^)^: `         errort(vec_head(v), "'##' cannot appear at start of macro expansion");`GoToNextLine ^(^

^)^: `         errort(vec_head(v), "'##' cannot appear at start of macro expansion");`GoToNextLine ^(^

^)^: `     if (is_keyword(vec_tail(v), KHASHHASH))`GoToNextLine ^(^

^)^: `     if (is_keyword(vec_tail(v), KHASHHASH))`GoToNextLine ^(^

^)^: `         errort(vec_tail(v), "'##' cannot appear at end of macro expansion");`GoToNextLine ^(^

^)^: `         errort(vec_tail(v), "'##' cannot appear at end of macro expansion");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *read_funclike_macro_body(Map *param) {`GoToNextLine ^(^

^)^: ` static Vector *read_funclike_macro_body(Map *param) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `         if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `         if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `             Token *subst = map_get(param, tok->sval);`GoToNextLine ^(^

^)^: `             Token *subst = map_get(param, tok->sval);`GoToNextLine ^(^

^)^: `             if (subst) {`GoToNextLine ^(^

^)^: `             if (subst) {`GoToNextLine ^(^

^)^: `                 subst = copy_token(subst);`GoToNextLine ^(^

^)^: `                 subst = copy_token(subst);`GoToNextLine ^(^

^)^: `                 subst->space = tok->space;`GoToNextLine ^(^

^)^: `                 subst->space = tok->space;`GoToNextLine ^(^

^)^: `                 vec_push(r, subst);`GoToNextLine ^(^

^)^: `                 vec_push(r, subst);`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_funclike_macro(Token *name) {`GoToNextLine ^(^

^)^: ` static void read_funclike_macro(Token *name) {`GoToNextLine ^(^

^)^: `     Map *param = make_map();`GoToNextLine ^(^

^)^: `     Map *param = make_map();`GoToNextLine ^(^

^)^: `     bool is_varg = read_funclike_macro_params(name, param);`GoToNextLine ^(^

^)^: `     bool is_varg = read_funclike_macro_params(name, param);`GoToNextLine ^(^

^)^: `     Vector *body = read_funclike_macro_body(param);`GoToNextLine ^(^

^)^: `     Vector *body = read_funclike_macro_body(param);`GoToNextLine ^(^

^)^: `     hashhash_check(body);`GoToNextLine ^(^

^)^: `     hashhash_check(body);`GoToNextLine ^(^

^)^: `     Macro *macro = make_func_macro(body, map_len(param), is_varg);`GoToNextLine ^(^

^)^: `     Macro *macro = make_func_macro(body, map_len(param), is_varg);`GoToNextLine ^(^

^)^: `     map_put(macros, name->sval, macro);`GoToNextLine ^(^

^)^: `     map_put(macros, name->sval, macro);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_obj_macro(char *name) {`GoToNextLine ^(^

^)^: ` static void read_obj_macro(char *name) {`GoToNextLine ^(^

^)^: `     Vector *body = make_vector();`GoToNextLine ^(^

^)^: `     Vector *body = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             break;`GoToNextLine ^(^

^)^: `         vec_push(body, tok);`GoToNextLine ^(^

^)^: `         vec_push(body, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     hashhash_check(body);`GoToNextLine ^(^

^)^: `     map_put(macros, name, make_obj_macro(body));`GoToNextLine ^(^

^)^: `     map_put(macros, name, make_obj_macro(body));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #define`GoToNextLine ^(^

^)^: `  * #define`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *name = read_ident();`GoToNextLine ^(^

^)^: `     Token *name = read_ident();`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (is_keyword(tok, '(') && !tok->space) {`GoToNextLine ^(^

^)^: `     if (is_keyword(tok, '(') && !tok->space) {`GoToNextLine ^(^

^)^: `         read_funclike_macro(name);`GoToNextLine ^(^

^)^: `         read_funclike_macro(name);`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `     read_obj_macro(name->sval);`GoToNextLine ^(^

^)^: `     read_obj_macro(name->sval);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #undef`GoToNextLine ^(^

^)^: `  * #undef`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *name = read_ident();`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     map_remove(macros, name->sval);`GoToNextLine ^(^

^)^: `     map_remove(macros, name->sval);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #if and the like`GoToNextLine ^(^

^)^: `  * #if and the like`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static Token *read_defined_op() {`GoToNextLine ^(^

^)^: ` static Token *read_defined_op() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (is_keyword(tok, '(')) {`GoToNextLine ^(^

^)^: `     if (is_keyword(tok, '(')) {`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     return map_get(macros, tok->sval) ? cpp_token_one : cpp_token_zero;`GoToNextLine ^(^

^)^: `     return map_get(macros, tok->sval) ? cpp_token_one : cpp_token_zero;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *read_intexpr_line() {`GoToNextLine ^(^

^)^: ` static Vector *read_intexpr_line() {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `         if (is_ident(tok, "defined")) {`GoToNextLine ^(^

^)^: `         if (is_ident(tok, "defined")) {`GoToNextLine ^(^

^)^: `         vec_push(r, make_vector());`GoToNextLine ^(^

^)^: `         } else if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `         } else if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `             // C11 6.10.1.4 says that remaining identifiers`GoToNextLine ^(^

^)^: `             // C11 6.10.1.4 says that remaining identifiers`GoToNextLine ^(^

^)^: `             // should be replaced with pp-number 0.`GoToNextLine ^(^

^)^: `             // should be replaced with pp-number 0.`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `         } else {`GoToNextLine ^(^

^)^: `         } else {`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool read_constexpr() {`GoToNextLine ^(^

^)^: ` static bool read_constexpr() {`GoToNextLine ^(^

^)^: `     token_buffer_stash(vec_reverse(read_intexpr_line()));`GoToNextLine ^(^

^)^: `     token_buffer_stash(vec_reverse(read_intexpr_line()));`GoToNextLine ^(^

^)^: `     Node *expr = read_expr();`GoToNextLine ^(^

^)^: `     Node *expr = read_expr();`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     return eval_intexpr(expr, NULL);`GoToNextLine ^(^

^)^: `     return eval_intexpr(expr, NULL);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void do_read_if(bool istrue) {`GoToNextLine ^(^

^)^: ` static void do_read_if(bool istrue) {`GoToNextLine ^(^

^)^: `     vec_push(cond_incl_stack, make_cond_incl(istrue));`GoToNextLine ^(^

^)^: `     vec_push(cond_incl_stack, make_cond_incl(istrue));`GoToNextLine ^(^

^)^: `     if (!istrue)`GoToNextLine ^(^

^)^: `     if (!istrue)`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     do_read_if(read_constexpr());`GoToNextLine ^(^

^)^: `     do_read_if(read_constexpr());`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     do_read_if(map_get(macros, tok->sval));`GoToNextLine ^(^

^)^: `     do_read_if(map_get(macros, tok->sval));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     do_read_if(!map_get(macros, tok->sval));`GoToNextLine ^(^

^)^: `     do_read_if(!map_get(macros, tok->sval));`GoToNextLine ^(^

^)^: `     if (tok->count == 2) {`GoToNextLine ^(^

^)^: `     if (tok->count == 2) {`GoToNextLine ^(^

^)^: `         // "ifndef" is the second token in this file.`GoToNextLine ^(^

^)^: `         // "ifndef" is the second token in this file.`GoToNextLine ^(^

^)^: `         // Prepare to detect an include guard.`GoToNextLine ^(^

^)^: `         // Prepare to detect an include guard.`GoToNextLine ^(^

^)^: `         CondIncl *ci = vec_tail(cond_incl_stack);`GoToNextLine ^(^

^)^: `         CondIncl *ci = vec_tail(cond_incl_stack);`GoToNextLine ^(^

^)^: `         ci->include_guard = tok->sval;`GoToNextLine ^(^

^)^: `         ci->include_guard = tok->sval;`GoToNextLine ^(^

^)^: `         ci->file = tok->file;`GoToNextLine ^(^

^)^: `         ci->file = tok->file;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     if (vec_len(cond_incl_stack) == 0)`GoToNextLine ^(^

^)^: `     if (vec_len(cond_incl_stack) == 0)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         CondIncl *ci = vec_tail(cond_incl_stack);`GoToNextLine ^(^

^)^: `     if (ci->ctx == IN_ELSE)`GoToNextLine ^(^

^)^: `     if (ci->ctx == IN_ELSE)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     r->ctx = IN_THEN;`GoToNextLine ^(^

^)^: `     ci->include_guard = NULL;`GoToNextLine ^(^

^)^: `     ci->include_guard = NULL;`GoToNextLine ^(^

^)^: `     if (ci->wastrue)`GoToNextLine ^(^

^)^: `     if (ci->wastrue)`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     if (vec_len(cond_incl_stack) == 0)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         CondIncl *ci = vec_tail(cond_incl_stack);`GoToNextLine ^(^

^)^: `     if (ci->ctx == IN_ELSE)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `     r->ctx = IN_THEN;`GoToNextLine ^(^

^)^: `     ci->include_guard = NULL;`GoToNextLine ^(^

^)^: `     if (ci->wastrue || !read_constexpr()) {`GoToNextLine ^(^

^)^: `     if (ci->wastrue || !read_constexpr()) {`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     ci->wastrue = true;`GoToNextLine ^(^

^)^: `     ci->wastrue = true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` // Skips all newlines and returns the first non-newline token.`GoToNextLine ^(^

^)^: ` // Skips all newlines and returns the first non-newline token.`GoToNextLine ^(^

^)^: ` static Token *skip_newlines() {`GoToNextLine ^(^

^)^: ` static Token *skip_newlines() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     while (tok->kind == TNEWLINE)`GoToNextLine ^(^

^)^: `     while (tok->kind == TNEWLINE)`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     if (vec_len(cond_incl_stack) == 0)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         CondIncl *ci = vec_tail(cond_incl_stack);`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     // Detect an #ifndef and #endif pair that guards the entire`GoToNextLine ^(^

^)^: `     // Detect an #ifndef and #endif pair that guards the entire`GoToNextLine ^(^

^)^: `     // header file. Remember the macro name guarding the file`GoToNextLine ^(^

^)^: `     // header file. Remember the macro name guarding the file`GoToNextLine ^(^

^)^: `     // so that we can skip the file next time.`GoToNextLine ^(^

^)^: `     // so that we can skip the file next time.`GoToNextLine ^(^

^)^: `     if (!ci->include_guard || ci->file != hash->file)`GoToNextLine ^(^

^)^: `     if (!ci->include_guard || ci->file != hash->file)`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `     Token *last = skip_newlines();`GoToNextLine ^(^

^)^: `     Token *last = skip_newlines();`GoToNextLine ^(^

^)^: `     if (ci->file != last->file)`GoToNextLine ^(^

^)^: `     if (ci->file != last->file)`GoToNextLine ^(^

^)^: `         map_put(include_guard, ci->file->name, ci->include_guard);`GoToNextLine ^(^

^)^: `         map_put(include_guard, ci->file->name, ci->include_guard);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #error and #warning`GoToNextLine ^(^

^)^: `  * #error and #warning`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static char *read_error_message() {`GoToNextLine ^(^

^)^: ` static char *read_error_message() {`GoToNextLine ^(^

^)^: `     Buffer *b = make_buffer();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             return buf_body(b);`GoToNextLine ^(^

^)^: `             return buf_body(b);`GoToNextLine ^(^

^)^: `         if (buf_len(b) != 0 && tok->space)`GoToNextLine ^(^

^)^: `         if (buf_len(b) != 0 && tok->space)`GoToNextLine ^(^

^)^: `             buf_write(b, ' ');`GoToNextLine ^(^

^)^: `             buf_write(b, ' ');`GoToNextLine ^(^

^)^: `         buf_printf(b, "%s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     errort(hash, "#error: %s", read_error_message());`GoToNextLine ^(^

^)^: `     errort(hash, "#error: %s", read_error_message());`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     errort(hash, "#error: %s", read_error_message());`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #include`GoToNextLine ^(^

^)^: `  * #include`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static char *join_paths(Vector *args) {`GoToNextLine ^(^

^)^: ` static char *join_paths(Vector *args) {`GoToNextLine ^(^

^)^: `     Buffer *b = make_buffer();`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(args); i++)`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(args); i++)`GoToNextLine ^(^

^)^: `         buf_printf(b, "%s", tok2s(vec_get(args, i)));`GoToNextLine ^(^

^)^: `         buf_printf(b, "%s", tok2s(vec_get(args, i)));`GoToNextLine ^(^

^)^: `             return buf_body(b);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static char *read_cpp_header_name(Token *hash, bool *std) {`GoToNextLine ^(^

^)^: ` static char *read_cpp_header_name(Token *hash, bool *std) {`GoToNextLine ^(^

^)^: `     // Try reading a filename using a special tokenizer for #include.`GoToNextLine ^(^

^)^: `     // Try reading a filename using a special tokenizer for #include.`GoToNextLine ^(^

^)^: `     char *path = read_header_file_name(std);`GoToNextLine ^(^

^)^: `     char *path = read_header_file_name(std);`GoToNextLine ^(^

^)^: `     if (path)`GoToNextLine ^(^

^)^: `     if (path)`GoToNextLine ^(^

^)^: `         return path;`GoToNextLine ^(^

^)^: `         return path;`GoToNextLine ^(^

^)^: `     // If a token following #include does not start with < nor ",`GoToNextLine ^(^

^)^: `     // If a token following #include does not start with < nor ",`GoToNextLine ^(^

^)^: `     // try to read the token as a regular token. Macro-expanded`GoToNextLine ^(^

^)^: `     // try to read the token as a regular token. Macro-expanded`GoToNextLine ^(^

^)^: `     // form may be a valid header file path.`GoToNextLine ^(^

^)^: `     // form may be a valid header file path.`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `         *std = false;`GoToNextLine ^(^

^)^: `         *std = false;`GoToNextLine ^(^

^)^: `         return tok->sval;`GoToNextLine ^(^

^)^: `         return tok->sval;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `             if (!is_keyword(tok, ','))`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     Vector *tokens = make_vector();`GoToNextLine ^(^

^)^: `     Vector *tokens = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, '('))`GoToNextLine ^(^

^)^: `             break;`GoToNextLine ^(^

^)^: `         propagate_space(tokens, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     *std = true;`GoToNextLine ^(^

^)^: `     *std = true;`GoToNextLine ^(^

^)^: `     return join_paths(tokens);`GoToNextLine ^(^

^)^: `     return join_paths(tokens);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool guarded(char *path) {`GoToNextLine ^(^

^)^: ` static bool guarded(char *path) {`GoToNextLine ^(^

^)^: `     char *guard = map_get(include_guard, path);`GoToNextLine ^(^

^)^: `     char *guard = map_get(include_guard, path);`GoToNextLine ^(^

^)^: `     bool r = (guard && map_get(macros, guard));`GoToNextLine ^(^

^)^: `     bool r = (guard && map_get(macros, guard));`GoToNextLine ^(^

^)^: `     define_obj_macro("__8cc_include_guard", r ? cpp_token_one : cpp_token_zero);`GoToNextLine ^(^

^)^: `     define_obj_macro("__8cc_include_guard", r ? cpp_token_one : cpp_token_zero);`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool try_include(char *dir, char *filename, bool isimport) {`GoToNextLine ^(^

^)^: ` static bool try_include(char *dir, char *filename, bool isimport) {`GoToNextLine ^(^

^)^: `     char *path = fullpath(format("%s/%s", dir, filename));`GoToNextLine ^(^

^)^: `     char *path = fullpath(format("%s/%s", dir, filename));`GoToNextLine ^(^

^)^: `     if (map_get(once, path))`GoToNextLine ^(^

^)^: `     if (map_get(once, path))`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: `     if (guarded(path))`GoToNextLine ^(^

^)^: `     if (guarded(path))`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: `     FILE *fp = fopen(path, "r");`GoToNextLine ^(^

^)^: `     FILE *fp = fopen(path, "r");`GoToNextLine ^(^

^)^: `     if (!fp)`GoToNextLine ^(^

^)^: `     if (!fp)`GoToNextLine ^(^

^)^: `     return false;`GoToNextLine ^(^

^)^: `     if (isimport)`GoToNextLine ^(^

^)^: `     if (isimport)`GoToNextLine ^(^

^)^: `         map_put(once, path, (void *)1);`GoToNextLine ^(^

^)^: `         map_put(once, path, (void *)1);`GoToNextLine ^(^

^)^: `     stream_push(make_file(fp, path));`GoToNextLine ^(^

^)^: `     stream_push(make_file(fp, path));`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_include(Token *hash, File *file, bool isimport) {`GoToNextLine ^(^

^)^: ` static void read_include(Token *hash, File *file, bool isimport) {`GoToNextLine ^(^

^)^: `     bool std;`GoToNextLine ^(^

^)^: `     bool std;`GoToNextLine ^(^

^)^: `     char *filename = read_cpp_header_name(hash, &std);`GoToNextLine ^(^

^)^: `     char *filename = read_cpp_header_name(hash, &std);`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     if (filename[0] == '/') {`GoToNextLine ^(^

^)^: `     if (filename[0] == '/') {`GoToNextLine ^(^

^)^: `         if (try_include("/", filename, isimport))`GoToNextLine ^(^

^)^: `         if (try_include("/", filename, isimport))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `         goto err;`GoToNextLine ^(^

^)^: `         goto err;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (!std) {`GoToNextLine ^(^

^)^: `     if (!std) {`GoToNextLine ^(^

^)^: `         char *dir = file->name ? dirname(strdup(file->name)) : ".";`GoToNextLine ^(^

^)^: `         char *dir = file->name ? dirname(strdup(file->name)) : ".";`GoToNextLine ^(^

^)^: `         if (try_include(dir, filename, isimport))`GoToNextLine ^(^

^)^: `         if (try_include(dir, filename, isimport))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(std_include_path); i++)`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(std_include_path); i++)`GoToNextLine ^(^

^)^: `         if (try_include(vec_get(std_include_path, i), filename, isimport))`GoToNextLine ^(^

^)^: `         if (try_include(vec_get(std_include_path, i), filename, isimport))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `   err:`GoToNextLine ^(^

^)^: `   err:`GoToNextLine ^(^

^)^: `     errort(hash, "cannot find header file: %s", filename);`GoToNextLine ^(^

^)^: `     errort(hash, "cannot find header file: %s", filename);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_include_next(Token *hash, File *file) {`GoToNextLine ^(^

^)^: ` static void read_include_next(Token *hash, File *file) {`GoToNextLine ^(^

^)^: `     // [GNU] #include_next is a directive to include the "next" file`GoToNextLine ^(^

^)^: `     // [GNU] #include_next is a directive to include the "next" file`GoToNextLine ^(^

^)^: `     // from the search path. This feature is used to override a`GoToNextLine ^(^

^)^: `     // from the search path. This feature is used to override a`GoToNextLine ^(^

^)^: `     // header file without getting into infinite inclusion loop.`GoToNextLine ^(^

^)^: `     // header file without getting into infinite inclusion loop.`GoToNextLine ^(^

^)^: `     // This directive doesn't distinguish <> and "".`GoToNextLine ^(^

^)^: `     // This directive doesn't distinguish <> and "".`GoToNextLine ^(^

^)^: `     bool std;`GoToNextLine ^(^

^)^: `     char *filename = read_cpp_header_name(hash, &std);`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     if (filename[0] == '/') {`GoToNextLine ^(^

^)^: `         if (try_include("/", filename, false))`GoToNextLine ^(^

^)^: `         if (try_include("/", filename, false))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `         goto err;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     char *cur = fullpath(file->name);`GoToNextLine ^(^

^)^: `     char *cur = fullpath(file->name);`GoToNextLine ^(^

^)^: `     int pos = 0;`GoToNextLine ^(^

^)^: `     for (; i < vec_len(std_include_path); i++) {`GoToNextLine ^(^

^)^: `     for (; i < vec_len(std_include_path); i++) {`GoToNextLine ^(^

^)^: `         char *dir = vec_get(std_include_path, i);`GoToNextLine ^(^

^)^: `         char *dir = vec_get(std_include_path, i);`GoToNextLine ^(^

^)^: `         if (!strcmp(cur, fullpath(format("%s/%s", dir, filename))))`GoToNextLine ^(^

^)^: `         if (!strcmp(cur, fullpath(format("%s/%s", dir, filename))))`GoToNextLine ^(^

^)^: `             break;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     for (i++; i < vec_len(std_include_path); i++)`GoToNextLine ^(^

^)^: `     for (i++; i < vec_len(std_include_path); i++)`GoToNextLine ^(^

^)^: `         if (try_include(vec_get(std_include_path, i), filename, false))`GoToNextLine ^(^

^)^: `         if (try_include(vec_get(std_include_path, i), filename, false))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `   err:`GoToNextLine ^(^

^)^: `     errort(hash, "cannot find header file: %s", filename);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #pragma`GoToNextLine ^(^

^)^: `  * #pragma`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void parse_pragma_operand(Token *tok) {`GoToNextLine ^(^

^)^: ` static void parse_pragma_operand(Token *tok) {`GoToNextLine ^(^

^)^: `     char *s = tok->sval;`GoToNextLine ^(^

^)^: `     char *s = tok->sval;`GoToNextLine ^(^

^)^: `     if (!strcmp(s, "once")) {`GoToNextLine ^(^

^)^: `     if (!strcmp(s, "once")) {`GoToNextLine ^(^

^)^: `         char *path = fullpath(tok->file->name);`GoToNextLine ^(^

^)^: `         char *path = fullpath(tok->file->name);`GoToNextLine ^(^

^)^: `         map_put(once, path, (void *)1);`GoToNextLine ^(^

^)^: `     } else if (!strcmp(s, "enable_warning")) {`GoToNextLine ^(^

^)^: `     } else if (!strcmp(s, "enable_warning")) {`GoToNextLine ^(^

^)^: `         enable_warning = true;`GoToNextLine ^(^

^)^: `         enable_warning = true;`GoToNextLine ^(^

^)^: `     } else if (!strcmp(s, "enable_warning")) {`GoToNextLine ^(^

^)^: `         enable_warning = false;`GoToNextLine ^(^

^)^: `         enable_warning = false;`GoToNextLine ^(^

^)^: `         } else {`GoToNextLine ^(^

^)^: `         errort(tok, "unknown #pragma: %s", s);`GoToNextLine ^(^

^)^: `         errort(tok, "unknown #pragma: %s", s);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #line`GoToNextLine ^(^

^)^: `  * #line`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static bool is_digit_sequence(char *p) {`GoToNextLine ^(^

^)^: ` static bool is_digit_sequence(char *p) {`GoToNextLine ^(^

^)^: `     for (; *p; p++)`GoToNextLine ^(^

^)^: `     for (; *p; p++)`GoToNextLine ^(^

^)^: `         if (!isdigit(*p))`GoToNextLine ^(^

^)^: `         if (!isdigit(*p))`GoToNextLine ^(^

^)^: `     return false;`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TNUMBER || !is_digit_sequence(tok->sval))`GoToNextLine ^(^

^)^: `     if (tok->kind != TNUMBER || !is_digit_sequence(tok->sval))`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     int line = atoi(tok->sval);`GoToNextLine ^(^

^)^: `     int line = atoi(tok->sval);`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `     char *filename = NULL;`GoToNextLine ^(^

^)^: `     char *filename = NULL;`GoToNextLine ^(^

^)^: `         if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `         filename = tok->sval;`GoToNextLine ^(^

^)^: `         filename = tok->sval;`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     } else if (tok->kind != TNEWLINE) {`GoToNextLine ^(^

^)^: `     } else if (tok->kind != TNEWLINE) {`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     File *f = current_file();`GoToNextLine ^(^

^)^: `     File *f = current_file();`GoToNextLine ^(^

^)^: `     f->line = line;`GoToNextLine ^(^

^)^: `     f->line = line;`GoToNextLine ^(^

^)^: `     if (filename)`GoToNextLine ^(^

^)^: `     if (filename)`GoToNextLine ^(^

^)^: `         f->name = filename;`GoToNextLine ^(^

^)^: `         f->name = filename;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` // GNU CPP outputs "# linenum filename flags" to preserve original`GoToNextLine ^(^

^)^: ` // GNU CPP outputs "# linenum filename flags" to preserve original`GoToNextLine ^(^

^)^: ` // source file information. This function reads them. Flags are ignored.`GoToNextLine ^(^

^)^: ` // source file information. This function reads them. Flags are ignored.`GoToNextLine ^(^

^)^: ` static void parse_pragma_operand(Token *tok) {`GoToNextLine ^(^

^)^: `     if (!is_digit_sequence(tok->sval))`GoToNextLine ^(^

^)^: `     if (!is_digit_sequence(tok->sval))`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     int line = atoi(tok->sval);`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     char *filename = tok->sval;`GoToNextLine ^(^

^)^: `     char *filename = tok->sval;`GoToNextLine ^(^

^)^: `     do {`GoToNextLine ^(^

^)^: `     do {`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `     } while (tok->kind != TNEWLINE);`GoToNextLine ^(^

^)^: `     } while (tok->kind != TNEWLINE);`GoToNextLine ^(^

^)^: `     File *file = current_file();`GoToNextLine ^(^

^)^: `     File *file = current_file();`GoToNextLine ^(^

^)^: `     file->line = line;`GoToNextLine ^(^

^)^: `     file->line = line;`GoToNextLine ^(^

^)^: `     file->name = filename;`GoToNextLine ^(^

^)^: `     file->name = filename;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #-directive`GoToNextLine ^(^

^)^: `  * #-directive`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `         if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         goto err;`GoToNextLine ^(^

^)^: `     char *s = tok->sval;`GoToNextLine ^(^

^)^: `     if (!strcmp(s, "define"))            read_define();`GoToNextLine ^(^

^)^: `     if (!strcmp(s, "define"))            read_define();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "import"))       read_include(hash, tok->file, true);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "import"))       read_include(hash, tok->file, true);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "include"))      read_include(hash, tok->file, false);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "include"))      read_include(hash, tok->file, false);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "include_next")) read_include_next(hash, tok->file);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "include_next")) read_include_next(hash, tok->file);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else goto err;`GoToNextLine ^(^

^)^: `     else goto err;`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `   err:`GoToNextLine ^(^

^)^: `     errort(hash, "unsupported preprocessor directive: %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     errort(hash, "unsupported preprocessor directive: %s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Special macros`GoToNextLine ^(^

^)^: `  * Special macros`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void make_token_pushback(Token *tmpl, int kind, char *sval) {`GoToNextLine ^(^

^)^: ` static void make_token_pushback(Token *tmpl, int kind, char *sval) {`GoToNextLine ^(^

^)^: `     Token *tok = copy_token(tmpl);`GoToNextLine ^(^

^)^: `     Token *tok = copy_token(tmpl);`GoToNextLine ^(^

^)^: `     r->kind = TMACRO_PARAM;`GoToNextLine ^(^

^)^: `     tok->sval = sval;`GoToNextLine ^(^

^)^: `     tok->sval = sval;`GoToNextLine ^(^

^)^: `     tok->slen = strlen(sval) + 1;`GoToNextLine ^(^

^)^: `     tok->slen = strlen(sval) + 1;`GoToNextLine ^(^

^)^: `     r->enc = ENC_NONE;`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     char buf[20];`GoToNextLine ^(^

^)^: `     char buf[20];`GoToNextLine ^(^

^)^: `     strftime(buf, sizeof(buf), "%b %e %Y", &now);`GoToNextLine ^(^

^)^: `     strftime(buf, sizeof(buf), "%b %e %Y", &now);`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, strdup(buf));`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, strdup(buf));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     char buf[10];`GoToNextLine ^(^

^)^: `     char buf[10];`GoToNextLine ^(^

^)^: `     strftime(buf, sizeof(buf), "%b %e %Y", &now);`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, strdup(buf));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     // [GNU] __TIMESTAMP__ is expanded to a string that describes the date`GoToNextLine ^(^

^)^: `     // [GNU] __TIMESTAMP__ is expanded to a string that describes the date`GoToNextLine ^(^

^)^: `     // and time of the last modification time of the current source file.`GoToNextLine ^(^

^)^: `     // and time of the last modification time of the current source file.`GoToNextLine ^(^

^)^: `     char buf[30];`GoToNextLine ^(^

^)^: `     char buf[30];`GoToNextLine ^(^

^)^: `     strftime(buf, sizeof(buf), "%a %b %e %T %Y", localtime(&tmpl->file->mtime));`GoToNextLine ^(^

^)^: `     strftime(buf, sizeof(buf), "%a %b %e %T %Y", localtime(&tmpl->file->mtime));`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, strdup(buf));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, tmpl->file->name);`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, tmpl->file->name);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, format("%d", tmpl->file->line));`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, format("%d", tmpl->file->line));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     expect('(');`GoToNextLine ^(^

^)^: `     expect('(');`GoToNextLine ^(^

^)^: `     Token *operand = read_token();`GoToNextLine ^(^

^)^: `     Token *operand = read_token();`GoToNextLine ^(^

^)^: `     if (operand->kind != TSTRING)`GoToNextLine ^(^

^)^: `     if (operand->kind != TSTRING)`GoToNextLine ^(^

^)^: `         errort(operand, "_Pragma takes a string literal, but got %s", tok2s(operand));`GoToNextLine ^(^

^)^: `         errort(operand, "_Pragma takes a string literal, but got %s", tok2s(operand));`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: `     parse_pragma_operand(operand);`GoToNextLine ^(^

^)^: `     parse_pragma_operand(operand);`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, "1");`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, "1");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, get_base_file());`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, get_base_file());`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     static int counter = 0;`GoToNextLine ^(^

^)^: `     static int counter = 0;`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, format("%d", counter++));`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, format("%d", counter++));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, format("%d", stream_depth() - 1));`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, format("%d", stream_depth() - 1));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Constructors`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` void add_include_path(char *path) {`GoToNextLine ^(^

^)^: ` void add_include_path(char *path) {`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, path);`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, path);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void define_obj_macro(char *name, Token *value) {`GoToNextLine ^(^

^)^: ` static void define_obj_macro(char *name, Token *value) {`GoToNextLine ^(^

^)^: `     map_put(macros, name, make_obj_macro(make_vector1(value)));`GoToNextLine ^(^

^)^: `     map_put(macros, name, make_obj_macro(make_vector1(value)));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void define_special_macro(char *name, SpecialMacroHandler *fn) {`GoToNextLine ^(^

^)^: ` static void define_special_macro(char *name, SpecialMacroHandler *fn) {`GoToNextLine ^(^

^)^: `     map_put(macros, name, make_special_macro(fn));`GoToNextLine ^(^

^)^: `     map_put(macros, name, make_special_macro(fn));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: ` #define op(id, str)         map_put(keywords, str, (void *)id);`GoToNextLine ^(^

^)^: ` #define op(id, str)         map_put(keywords, str, (void *)id);`GoToNextLine ^(^

^)^: ` #define keyword(id, str, _) map_put(keywords, str, (void *)id);`GoToNextLine ^(^

^)^: ` #define keyword(id, str, _) map_put(keywords, str, (void *)id);`GoToNextLine ^(^

^)^: ` #include "8cc.h"`GoToNextLine ^(^

^)^: ` #undef keyword`GoToNextLine ^(^

^)^: ` #undef keyword`GoToNextLine ^(^

^)^: ` #undef op`GoToNextLine ^(^

^)^: ` #undef op`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, BUILD_DIR "/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, BUILD_DIR "/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     define_special_macro("__DATE__", handle_date_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__DATE__", handle_date_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__TIME__", handle_time_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__TIME__", handle_time_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__FILE__", handle_file_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__FILE__", handle_file_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__LINE__", handle_line_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__LINE__", handle_line_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("_Pragma",  handle_pragma_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("_Pragma",  handle_pragma_macro);`GoToNextLine ^(^

^)^: `     // [GNU] Non-standard macros`GoToNextLine ^(^

^)^: `     // [GNU] Non-standard macros`GoToNextLine ^(^

^)^: `     define_special_macro("__BASE_FILE__", handle_base_file_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__BASE_FILE__", handle_base_file_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__COUNTER__", handle_counter_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__COUNTER__", handle_counter_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__INCLUDE_LEVEL__", handle_include_level_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__INCLUDE_LEVEL__", handle_include_level_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__TIMESTAMP__", handle_timestamp_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__TIMESTAMP__", handle_timestamp_macro);`GoToNextLine ^(^

^)^: `     read_from_string("#include <" BUILD_DIR "/include/8cc.h>");`GoToNextLine ^(^

^)^: `     read_from_string("#include <" BUILD_DIR "/include/8cc.h>");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` void expect_newline() {`GoToNextLine ^(^

^)^: `     time_t timet = time(NULL);`GoToNextLine ^(^

^)^: `     time_t timet = time(NULL);`GoToNextLine ^(^

^)^: `     localtime_r(&timet, &now);`GoToNextLine ^(^

^)^: `     localtime_r(&timet, &now);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` void expect_newline() {`GoToNextLine ^(^

^)^: `     setlocale(LC_ALL, "C");`GoToNextLine ^(^

^)^: `     setlocale(LC_ALL, "C");`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Public intefaces`GoToNextLine ^(^

^)^: `  * Public intefaces`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static Token *maybe_convert_keyword(Token *tok) {`GoToNextLine ^(^

^)^: ` static Token *maybe_convert_keyword(Token *tok) {`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     int id = (intptr_t)map_get(keywords, tok->sval);`GoToNextLine ^(^

^)^: `     int id = (intptr_t)map_get(keywords, tok->sval);`GoToNextLine ^(^

^)^: `     if (!id)`GoToNextLine ^(^

^)^: `     if (!id)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     Token *r = copy_token(tok);`GoToNextLine ^(^

^)^: `     Token *r = copy_token(tok);`GoToNextLine ^(^

^)^: `     r->kind = TMACRO_PARAM;`GoToNextLine ^(^

^)^: `     r->id = id;`GoToNextLine ^(^

^)^: `     r->id = id;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` // Reads from a string as if the string is a content of input file.`GoToNextLine ^(^

^)^: ` // Reads from a string as if the string is a content of input file.`GoToNextLine ^(^

^)^: ` // Convenient for evaluating small string snippet contaiing preprocessor macros.`GoToNextLine ^(^

^)^: ` // Convenient for evaluating small string snippet contaiing preprocessor macros.`GoToNextLine ^(^

^)^: ` void read_from_string(char *buf) {`GoToNextLine ^(^

^)^: ` void read_from_string(char *buf) {`GoToNextLine ^(^

^)^: `     stream_stash(make_file_string(buf));`GoToNextLine ^(^

^)^: `     stream_stash(make_file_string(buf));`GoToNextLine ^(^

^)^: `     Vector *toplevels = read_toplevels();`GoToNextLine ^(^

^)^: `     Vector *toplevels = read_toplevels();`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(toplevels); i++)`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(toplevels); i++)`GoToNextLine ^(^

^)^: `         emit_toplevel(vec_get(toplevels, i));`GoToNextLine ^(^

^)^: `         emit_toplevel(vec_get(toplevels, i));`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` Token *peek_token() {`GoToNextLine ^(^

^)^: ` Token *peek_token() {`GoToNextLine ^(^

^)^: `     Token *r = read_token();`GoToNextLine ^(^

^)^: `     Token *r = read_token();`GoToNextLine ^(^

^)^: `                     vec_pop(r);`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` Token *read_token() {`GoToNextLine ^(^

^)^: ` Token *read_token() {`GoToNextLine ^(^

^)^: `     Token *tok;`GoToNextLine ^(^

^)^: `     Token *tok;`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->bol && is_keyword(tok, '#') && tok->hideset == NULL) {`GoToNextLine ^(^

^)^: `         if (tok->bol && is_keyword(tok, '#') && tok->hideset == NULL) {`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         assert(tok->kind < MIN_CPP_TOKEN);`GoToNextLine ^(^

^)^: `         assert(tok->kind < MIN_CPP_TOKEN);`GoToNextLine ^(^

^)^: `         return maybe_convert_keyword(tok);`GoToNextLine ^(^

^)^: `         return maybe_convert_keyword(tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` int main() {`GoToNextLine ^(^

^)^: ` int main() {`GoToNextLine ^(^

^)^: `    int i, j, rows;`GoToNextLine ^(^

^)^: `    int i, j, rows;`GoToNextLine ^(^

^)^: `    printf("Enter the number of rows: ");`GoToNextLine ^(^

^)^: `    printf("Enter the number of rows: ");`GoToNextLine ^(^

^)^: `    scanf("%d", &rows);`GoToNextLine ^(^

^)^: `    scanf("%d", &rows);`GoToNextLine ^(^

^)^: `    for (i = 1; i <= rows; ++i) {`GoToNextLine ^(^

^)^: `    for (i = 1; i <= rows; ++i) {`GoToNextLine ^(^

^)^: `       for (j = 1; j <= i; ++j) {`GoToNextLine ^(^

^)^: `       for (j = 1; j <= i; ++j) {`GoToNextLine ^(^

^)^: `          printf("* ");`GoToNextLine ^(^

^)^: `          printf("* ");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `       printf("\n");`GoToNextLine ^(^

^)^: `       printf("\n");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` // Copyright 2012 Rui Ueyama. Released under the MIT license.`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * This implements Dave Prosser's C Preprocessing algorithm, described`GoToNextLine ^(^

^)^: `  * in this document: https://github.com/rui314/8cc/wiki/cpp.algo.pdf`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include <string.h>`GoToNextLine ^(^

^)^: ` #include <time.h>`GoToNextLine ^(^

^)^: ` #include <ctype.h>`GoToNextLine ^(^

^)^: ` #include "8cc.h"`GoToNextLine ^(^

^)^: ` static Map *macros = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *once = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *keywords = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Map *include_guard = &EMPTY_MAP;`GoToNextLine ^(^

^)^: ` static Vector *cond_incl_stack = &EMPTY_VECTOR;`GoToNextLine ^(^

^)^: ` static Vector *std_include_path = &EMPTY_VECTOR;`GoToNextLine ^(^

^)^: ` static struct tm now;`GoToNextLine ^(^

^)^: ` static Token *cpp_token_zero = &(Token){ .kind = TNUMBER, .sval = "0" };`GoToNextLine ^(^

^)^: ` static Token *cpp_token_one = &(Token){ .kind = TNUMBER, .sval = "1" };`GoToNextLine ^(^

^)^: ` typedef void SpecialMacroHandler(Token *tok);`GoToNextLine ^(^

^)^: ` typedef enum { IN_THEN, IN_ELIF, IN_ELSE } CondInclCtx;`GoToNextLine ^(^

^)^: ` typedef enum { IN_THEN, IN_ELIF, IN_ELSE } CondInclCtx;`GoToNextLine ^(^

^)^: ` typedef struct {`GoToNextLine ^(^

^)^: `     CondInclCtx ctx;`GoToNextLine ^(^

^)^: `     char *include_guard;`GoToNextLine ^(^

^)^: `     File *file;`GoToNextLine ^(^

^)^: `     bool wastrue;`GoToNextLine ^(^

^)^: ` } CondIncl;`GoToNextLine ^(^

^)^: ` typedef struct {`GoToNextLine ^(^

^)^: `     CondInclCtx ctx;`GoToNextLine ^(^

^)^: `     int nargs;`GoToNextLine ^(^

^)^: `     Vector *body;`GoToNextLine ^(^

^)^: `     bool wastrue;`GoToNextLine ^(^

^)^: `     SpecialMacroHandler *fn;`GoToNextLine ^(^

^)^: ` } Macro;`GoToNextLine ^(^

^)^: ` static Macro *make_obj_macro(Vector *body);`GoToNextLine ^(^

^)^: ` static Macro *make_func_macro(Vector *body, int nargs, bool is_varg);`GoToNextLine ^(^

^)^: ` static Macro *make_special_macro(SpecialMacroHandler *fn);`GoToNextLine ^(^

^)^: ` static void define_obj_macro(char *name, Token *value);`GoToNextLine ^(^

^)^: ` static void read_directive(Token *hash);`GoToNextLine ^(^

^)^: ` static Token *read_expand(void);`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Constructors`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static CondIncl *make_cond_incl(bool wastrue) {`GoToNextLine ^(^

^)^: `     CondIncl *r = calloc(1, sizeof(CondIncl));`GoToNextLine ^(^

^)^: `     r->ctx = IN_THEN;`GoToNextLine ^(^

^)^: `     r->wastrue = wastrue;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Macro *make_macro(Macro *tmpl) {`GoToNextLine ^(^

^)^: `     Macro *r = malloc(sizeof(Macro));`GoToNextLine ^(^

^)^: `     *r = *tmpl;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Macro *make_obj_macro(Vector *body) {`GoToNextLine ^(^

^)^: `     return make_macro(&(Macro){ MACRO_OBJ, .body = body });`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Macro *make_func_macro(Vector *body, int nargs, bool is_varg) {`GoToNextLine ^(^

^)^: `     return make_macro(&(Macro){`GoToNextLine ^(^

^)^: `             MACRO_FUNC, .nargs = nargs, .body = body, .is_varg = is_varg });`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Macro *make_special_macro(SpecialMacroHandler *fn) {`GoToNextLine ^(^

^)^: `     return make_macro(&(Macro){ MACRO_SPECIAL, .fn = fn });`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *make_macro_token(int position, bool is_vararg) {`GoToNextLine ^(^

^)^: `     Token *r = malloc(sizeof(Token));`GoToNextLine ^(^

^)^: `     r->kind = TMACRO_PARAM;`GoToNextLine ^(^

^)^: `     r->is_vararg = is_vararg;`GoToNextLine ^(^

^)^: `     r->hideset = NULL;`GoToNextLine ^(^

^)^: `     r->position = position;`GoToNextLine ^(^

^)^: `     r->space = false;`GoToNextLine ^(^

^)^: `     r->bol = false;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *copy_token(Token *tok) {`GoToNextLine ^(^

^)^: `     Token *r = malloc(sizeof(Token));`GoToNextLine ^(^

^)^: `     *r = *tok;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void expect(char id) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (!is_keyword(tok, id))`GoToNextLine ^(^

^)^: `         errort(tok, "%c expected, but got %s", id, tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Utility functions`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` bool is_ident(Token *tok, char *s) {`GoToNextLine ^(^

^)^: `     return tok->kind == TIDENT && !strcmp(tok->sval, s);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool next(int id) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (is_keyword(tok, id))`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `     return false;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void propagate_space(Vector *tokens, Token *tmpl) {`GoToNextLine ^(^

^)^: `     if (vec_len(tokens) == 0)`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `     Token *tok = copy_token(vec_head(tokens));`GoToNextLine ^(^

^)^: `     tok->space = tmpl->space;`GoToNextLine ^(^

^)^: `     vec_set(tokens, 0, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Macro expander`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static Token *read_ident() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` void expect_newline() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *read_one_arg(Token *ident, bool *end, bool readall) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     int level = 0;`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             errort(ident, "unterminated macro argument list");`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: `         if (tok->bol && is_keyword(tok, '#')) {`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (level == 0 && is_keyword(tok, ')')) {`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `             *end = true;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (level == 0 && is_keyword(tok, ',') && !readall)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, '('))`GoToNextLine ^(^

^)^: `             level++;`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, '('))`GoToNextLine ^(^

^)^: `             level--;`GoToNextLine ^(^

^)^: `         // C11 6.10.3p10: Within the macro argument list,`GoToNextLine ^(^

^)^: `         // newline is considered a normal whitespace character.`GoToNextLine ^(^

^)^: `         // I don't know why the standard specifies such a minor detail,`GoToNextLine ^(^

^)^: `         // but the difference of newline and space is observable`GoToNextLine ^(^

^)^: `         // if you stringize tokens using #.`GoToNextLine ^(^

^)^: `         if (tok->bol) {`GoToNextLine ^(^

^)^: `             tok = copy_token(tok);`GoToNextLine ^(^

^)^: `     r->bol = false;`GoToNextLine ^(^

^)^: `             tok->space = true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *do_read_args(Token *ident, Macro *macro) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     bool end = false;`GoToNextLine ^(^

^)^: `     while (!end) {`GoToNextLine ^(^

^)^: `         bool in_ellipsis = (macro->is_varg && vec_len(r) + 1 == macro->nargs);`GoToNextLine ^(^

^)^: `         vec_push(r, read_one_arg(ident, &end, in_ellipsis));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (macro->is_varg && vec_len(r) == macro->nargs - 1)`GoToNextLine ^(^

^)^: `         vec_push(r, make_vector());`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *read_args(Token *tok, Macro *macro) {`GoToNextLine ^(^

^)^: `     if (macro->nargs == 0 && is_keyword(peek_token(), ')')) {`GoToNextLine ^(^

^)^: `         // If a macro M has no parameter, argument list of M()`GoToNextLine ^(^

^)^: `         // is an empty list. If it has one parameter,`GoToNextLine ^(^

^)^: `         // argument list of M() is a list containing an empty list.`GoToNextLine ^(^

^)^: `         return make_vector();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     Vector *args = do_read_args(tok, macro);`GoToNextLine ^(^

^)^: `     if (vec_len(args) != macro->nargs)`GoToNextLine ^(^

^)^: `         errort(tok, "macro argument number does not match");`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *add_hide_set(Vector *tokens, Set *hideset) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(tokens); i++) {`GoToNextLine ^(^

^)^: `         Token *t = copy_token(vec_get(tokens, i));`GoToNextLine ^(^

^)^: `         t->hideset = set_union(t->hideset, hideset);`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *glue_tokens(Token *t, Token *u) {`GoToNextLine ^(^

^)^: `     Buffer *b = make_buffer();`GoToNextLine ^(^

^)^: `     buf_printf(b, "%s", tok2s(t));`GoToNextLine ^(^

^)^: `     buf_printf(b, "%s", tok2s(u));`GoToNextLine ^(^

^)^: `     Token *r = lex_string(buf_body(b));`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void glue_push(Vector *tokens, Token *tok) {`GoToNextLine ^(^

^)^: `     Token *last = vec_pop(tokens);`GoToNextLine ^(^

^)^: `     vec_push(tokens, glue_tokens(last, tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *stringize(Token *tmpl, Vector *args) {`GoToNextLine ^(^

^)^: `     Buffer *b = make_buffer();`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(args); i++) {`GoToNextLine ^(^

^)^: `         Token *tok = vec_get(args, i);`GoToNextLine ^(^

^)^: `         if (buf_len(b) && tok->space)`GoToNextLine ^(^

^)^: `             buf_printf(b, " ");`GoToNextLine ^(^

^)^: `         buf_printf(b, "%s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     buf_write(b, '\0');`GoToNextLine ^(^

^)^: `     Token *r = copy_token(tmpl);`GoToNextLine ^(^

^)^: `     r->kind = TMACRO_PARAM;`GoToNextLine ^(^

^)^: `     r->sval = buf_body(b);`GoToNextLine ^(^

^)^: `     r->slen = buf_len(b);`GoToNextLine ^(^

^)^: `     r->enc = ENC_NONE;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *expand_all(Vector *tokens, Token *tmpl) {`GoToNextLine ^(^

^)^: `     token_buffer_stash(vec_reverse(tokens));`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             break;`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *subst(Macro *macro, Vector *args, Set *hideset) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     int len = vec_len(macro->body);`GoToNextLine ^(^

^)^: `     for (int i = 0; i < len; i++) {`GoToNextLine ^(^

^)^: `         Token *t0 = vec_get(macro->body, i);`GoToNextLine ^(^

^)^: `         Token *t1 = (i == len - 1) ? NULL : vec_get(macro->body, i + 1);`GoToNextLine ^(^

^)^: `         bool t0_param = (t0->kind == TMACRO_PARAM);`GoToNextLine ^(^

^)^: `         bool t1_param = (t1 && t1->kind == TMACRO_PARAM);`GoToNextLine ^(^

^)^: `         if (is_keyword(t0, '#') && t1_param) {`GoToNextLine ^(^

^)^: `             vec_push(r, stringize(t0, vec_get(args, t1->position)));`GoToNextLine ^(^

^)^: `             i++;`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (is_keyword(t0, KHASHHASH) && t1_param) {`GoToNextLine ^(^

^)^: `             Vector *arg = vec_get(args, t1->position);`GoToNextLine ^(^

^)^: `             // [GNU] [,##__VA_ARG__] is expanded to the empty token sequence`GoToNextLine ^(^

^)^: `             // if __VA_ARG__ is empty. Otherwise it's expanded to`GoToNextLine ^(^

^)^: `             // [,<tokens in __VA_ARG__>].`GoToNextLine ^(^

^)^: `             if (t1->is_vararg && vec_len(r) > 0 && is_keyword(vec_tail(r), ',')) {`GoToNextLine ^(^

^)^: `                 if (vec_len(arg) > 0)`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `                 else`GoToNextLine ^(^

^)^: `                     vec_pop(r);`GoToNextLine ^(^

^)^: `             } else if (vec_len(arg) > 0) {`GoToNextLine ^(^

^)^: `                 glue_push(r, vec_head(arg));`GoToNextLine ^(^

^)^: `                 for (int i = 1; i < vec_len(arg); i++)`GoToNextLine ^(^

^)^: `                     vec_push(r, vec_get(arg, i));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `             i++;`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (is_keyword(t0, KHASHHASH) && t1_param) {`GoToNextLine ^(^

^)^: `             hideset = t1->hideset;`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `             i++;`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (t0_param && t1 && is_keyword(t1, KHASHHASH)) {`GoToNextLine ^(^

^)^: `             hideset = t1->hideset;`GoToNextLine ^(^

^)^: `             Vector *arg = vec_get(args, t1->position);`GoToNextLine ^(^

^)^: `             if (vec_len(arg) == 0)`GoToNextLine ^(^

^)^: `             i++;`GoToNextLine ^(^

^)^: `                 else`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (t0_param) {`GoToNextLine ^(^

^)^: `             Vector *arg = vec_get(args, t1->position);`GoToNextLine ^(^

^)^: `                     vec_push(r, vec_get(arg, i));`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     return add_hide_set(r, hideset);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void unget_all(Vector *tokens) {`GoToNextLine ^(^

^)^: `     for (int i = vec_len(tokens) - 1; i >= 0; i--)`GoToNextLine ^(^

^)^: `         unget_token(vec_get(tokens, i));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` // This is "expand" function in the Dave Prosser's document.`GoToNextLine ^(^

^)^: ` static Token *read_expand_newline() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     char *name = tok->sval;`GoToNextLine ^(^

^)^: `     Macro *macro = map_get(macros, name);`GoToNextLine ^(^

^)^: `     if (!macro || set_has(tok->hideset, name))`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     switch (macro->kind) {`GoToNextLine ^(^

^)^: `     case MACRO_OBJ: {`GoToNextLine ^(^

^)^: `         Set *hideset = set_add(tok->hideset, name);`GoToNextLine ^(^

^)^: `         Vector *tokens = subst(macro, NULL, hideset);`GoToNextLine ^(^

^)^: `         propagate_space(tokens, tok);`GoToNextLine ^(^

^)^: `         unget_all(tokens);`GoToNextLine ^(^

^)^: `         return make_vector();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     case MACRO_OBJ: {`GoToNextLine ^(^

^)^: `         if (!next('('))`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     Vector *args = do_read_args(tok, macro);`GoToNextLine ^(^

^)^: `         Token *rparen = peek_token();`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: `         Set *hideset = set_add(set_intersection(tok->hideset, rparen->hideset), name);`GoToNextLine ^(^

^)^: `         Vector *tokens = subst(macro, args, hideset);`GoToNextLine ^(^

^)^: `         propagate_space(tokens, tok);`GoToNextLine ^(^

^)^: `         unget_all(tokens);`GoToNextLine ^(^

^)^: `         return make_vector();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     case MACRO_SPECIAL:`GoToNextLine ^(^

^)^: `         macro->fn(tok);`GoToNextLine ^(^

^)^: `         return make_vector();`GoToNextLine ^(^

^)^: `     default:`GoToNextLine ^(^

^)^: `         error("internal error");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Token *read_expand() {`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool read_funclike_macro_params(Token *name, Map *param) {`GoToNextLine ^(^

^)^: `     int pos = 0;`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, '('))`GoToNextLine ^(^

^)^: `     return false;`GoToNextLine ^(^

^)^: `         if (pos) {`GoToNextLine ^(^

^)^: `             if (!is_keyword(tok, ','))`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             errort(name, "missing ')' in macro parameter list");`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, KELLIPSIS)) {`GoToNextLine ^(^

^)^: `             map_put(param, "__VA_ARGS__", make_macro_token(pos++, true));`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `         char *arg = tok->sval;`GoToNextLine ^(^

^)^: `         if (next(KELLIPSIS)) {`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: `             map_put(param, arg, make_macro_token(pos++, true));`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         map_put(param, arg, make_macro_token(pos++, false));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void hashhash_check(Vector *v) {`GoToNextLine ^(^

^)^: `     if (vec_len(v) == 0)`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `     if (is_keyword(vec_head(v), KHASHHASH))`GoToNextLine ^(^

^)^: `         errort(vec_head(v), "'##' cannot appear at start of macro expansion");`GoToNextLine ^(^

^)^: `     if (is_keyword(vec_tail(v), KHASHHASH))`GoToNextLine ^(^

^)^: `         errort(vec_tail(v), "'##' cannot appear at end of macro expansion");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *read_funclike_macro_body(Map *param) {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `         if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `             Token *subst = map_get(param, tok->sval);`GoToNextLine ^(^

^)^: `             if (subst) {`GoToNextLine ^(^

^)^: `                 subst = copy_token(subst);`GoToNextLine ^(^

^)^: `                 subst->space = tok->space;`GoToNextLine ^(^

^)^: `                 vec_push(r, subst);`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_funclike_macro(Token *name) {`GoToNextLine ^(^

^)^: `     Map *param = make_map();`GoToNextLine ^(^

^)^: `     bool is_varg = read_funclike_macro_params(name, param);`GoToNextLine ^(^

^)^: `     Vector *body = read_funclike_macro_body(param);`GoToNextLine ^(^

^)^: `     hashhash_check(body);`GoToNextLine ^(^

^)^: `     Macro *macro = make_func_macro(body, map_len(param), is_varg);`GoToNextLine ^(^

^)^: `     map_put(macros, name->sval, macro);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_obj_macro(char *name) {`GoToNextLine ^(^

^)^: `     Vector *body = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             break;`GoToNextLine ^(^

^)^: `         vec_push(body, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     hashhash_check(body);`GoToNextLine ^(^

^)^: `     map_put(macros, name, make_obj_macro(body));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #define`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *name = read_ident();`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (is_keyword(tok, '(') && !tok->space) {`GoToNextLine ^(^

^)^: `         read_funclike_macro(name);`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `     read_obj_macro(name->sval);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #undef`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *name = read_ident();`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     map_remove(macros, name->sval);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #if and the like`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static Token *read_defined_op() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (is_keyword(tok, '(')) {`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     return map_get(macros, tok->sval) ? cpp_token_one : cpp_token_zero;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static Vector *read_intexpr_line() {`GoToNextLine ^(^

^)^: `     Vector *r = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `         if (is_ident(tok, "defined")) {`GoToNextLine ^(^

^)^: `         vec_push(r, make_vector());`GoToNextLine ^(^

^)^: `         } else if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `             // C11 6.10.1.4 says that remaining identifiers`GoToNextLine ^(^

^)^: `             // should be replaced with pp-number 0.`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: `         } else {`GoToNextLine ^(^

^)^: `         vec_push(r, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool read_constexpr() {`GoToNextLine ^(^

^)^: `     token_buffer_stash(vec_reverse(read_intexpr_line()));`GoToNextLine ^(^

^)^: `     Node *expr = read_expr();`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     return eval_intexpr(expr, NULL);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void do_read_if(bool istrue) {`GoToNextLine ^(^

^)^: `     vec_push(cond_incl_stack, make_cond_incl(istrue));`GoToNextLine ^(^

^)^: `     if (!istrue)`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     do_read_if(read_constexpr());`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     do_read_if(map_get(macros, tok->sval));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     do_read_if(!map_get(macros, tok->sval));`GoToNextLine ^(^

^)^: `     if (tok->count == 2) {`GoToNextLine ^(^

^)^: `         // "ifndef" is the second token in this file.`GoToNextLine ^(^

^)^: `         // Prepare to detect an include guard.`GoToNextLine ^(^

^)^: `         CondIncl *ci = vec_tail(cond_incl_stack);`GoToNextLine ^(^

^)^: `         ci->include_guard = tok->sval;`GoToNextLine ^(^

^)^: `         ci->file = tok->file;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     if (vec_len(cond_incl_stack) == 0)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         CondIncl *ci = vec_tail(cond_incl_stack);`GoToNextLine ^(^

^)^: `     if (ci->ctx == IN_ELSE)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     r->ctx = IN_THEN;`GoToNextLine ^(^

^)^: `     ci->include_guard = NULL;`GoToNextLine ^(^

^)^: `     if (ci->wastrue)`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     if (vec_len(cond_incl_stack) == 0)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         CondIncl *ci = vec_tail(cond_incl_stack);`GoToNextLine ^(^

^)^: `     if (ci->ctx == IN_ELSE)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `     r->ctx = IN_THEN;`GoToNextLine ^(^

^)^: `     ci->include_guard = NULL;`GoToNextLine ^(^

^)^: `     if (ci->wastrue || !read_constexpr()) {`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     ci->wastrue = true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` // Skips all newlines and returns the first non-newline token.`GoToNextLine ^(^

^)^: ` static Token *skip_newlines() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     while (tok->kind == TNEWLINE)`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     if (vec_len(cond_incl_stack) == 0)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         CondIncl *ci = vec_tail(cond_incl_stack);`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     // Detect an #ifndef and #endif pair that guards the entire`GoToNextLine ^(^

^)^: `     // header file. Remember the macro name guarding the file`GoToNextLine ^(^

^)^: `     // so that we can skip the file next time.`GoToNextLine ^(^

^)^: `     if (!ci->include_guard || ci->file != hash->file)`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `     Token *last = skip_newlines();`GoToNextLine ^(^

^)^: `     if (ci->file != last->file)`GoToNextLine ^(^

^)^: `         map_put(include_guard, ci->file->name, ci->include_guard);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #error and #warning`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static char *read_error_message() {`GoToNextLine ^(^

^)^: `     Buffer *b = make_buffer();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `             return buf_body(b);`GoToNextLine ^(^

^)^: `         if (buf_len(b) != 0 && tok->space)`GoToNextLine ^(^

^)^: `             buf_write(b, ' ');`GoToNextLine ^(^

^)^: `         buf_printf(b, "%s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     errort(hash, "#error: %s", read_error_message());`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     errort(hash, "#error: %s", read_error_message());`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #include`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static char *join_paths(Vector *args) {`GoToNextLine ^(^

^)^: `     Buffer *b = make_buffer();`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(args); i++)`GoToNextLine ^(^

^)^: `         buf_printf(b, "%s", tok2s(vec_get(args, i)));`GoToNextLine ^(^

^)^: `             return buf_body(b);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static char *read_cpp_header_name(Token *hash, bool *std) {`GoToNextLine ^(^

^)^: `     // Try reading a filename using a special tokenizer for #include.`GoToNextLine ^(^

^)^: `     char *path = read_header_file_name(std);`GoToNextLine ^(^

^)^: `     if (path)`GoToNextLine ^(^

^)^: `         return path;`GoToNextLine ^(^

^)^: `     // If a token following #include does not start with < nor ",`GoToNextLine ^(^

^)^: `     // try to read the token as a regular token. Macro-expanded`GoToNextLine ^(^

^)^: `     // form may be a valid header file path.`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `         *std = false;`GoToNextLine ^(^

^)^: `         return tok->sval;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `             if (!is_keyword(tok, ','))`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     Vector *tokens = make_vector();`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `         errort(hash, "stray #else");`GoToNextLine ^(^

^)^: `         if (is_keyword(tok, '('))`GoToNextLine ^(^

^)^: `             break;`GoToNextLine ^(^

^)^: `         propagate_space(tokens, tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     *std = true;`GoToNextLine ^(^

^)^: `     return join_paths(tokens);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool guarded(char *path) {`GoToNextLine ^(^

^)^: `     char *guard = map_get(include_guard, path);`GoToNextLine ^(^

^)^: `     bool r = (guard && map_get(macros, guard));`GoToNextLine ^(^

^)^: `     define_obj_macro("__8cc_include_guard", r ? cpp_token_one : cpp_token_zero);`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static bool try_include(char *dir, char *filename, bool isimport) {`GoToNextLine ^(^

^)^: `     char *path = fullpath(format("%s/%s", dir, filename));`GoToNextLine ^(^

^)^: `     if (map_get(once, path))`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: `     if (guarded(path))`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: `     FILE *fp = fopen(path, "r");`GoToNextLine ^(^

^)^: `     if (!fp)`GoToNextLine ^(^

^)^: `     return false;`GoToNextLine ^(^

^)^: `     if (isimport)`GoToNextLine ^(^

^)^: `         map_put(once, path, (void *)1);`GoToNextLine ^(^

^)^: `     stream_push(make_file(fp, path));`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_include(Token *hash, File *file, bool isimport) {`GoToNextLine ^(^

^)^: `     bool std;`GoToNextLine ^(^

^)^: `     char *filename = read_cpp_header_name(hash, &std);`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     if (filename[0] == '/') {`GoToNextLine ^(^

^)^: `         if (try_include("/", filename, isimport))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `         goto err;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (!std) {`GoToNextLine ^(^

^)^: `         char *dir = file->name ? dirname(strdup(file->name)) : ".";`GoToNextLine ^(^

^)^: `         if (try_include(dir, filename, isimport))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(std_include_path); i++)`GoToNextLine ^(^

^)^: `         if (try_include(vec_get(std_include_path, i), filename, isimport))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `   err:`GoToNextLine ^(^

^)^: `     errort(hash, "cannot find header file: %s", filename);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_include_next(Token *hash, File *file) {`GoToNextLine ^(^

^)^: `     // [GNU] #include_next is a directive to include the "next" file`GoToNextLine ^(^

^)^: `     // from the search path. This feature is used to override a`GoToNextLine ^(^

^)^: `     // header file without getting into infinite inclusion loop.`GoToNextLine ^(^

^)^: `     // This directive doesn't distinguish <> and "".`GoToNextLine ^(^

^)^: `     bool std;`GoToNextLine ^(^

^)^: `     char *filename = read_cpp_header_name(hash, &std);`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     if (filename[0] == '/') {`GoToNextLine ^(^

^)^: `         if (try_include("/", filename, false))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `         goto err;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     char *cur = fullpath(file->name);`GoToNextLine ^(^

^)^: `     int pos = 0;`GoToNextLine ^(^

^)^: `     for (; i < vec_len(std_include_path); i++) {`GoToNextLine ^(^

^)^: `         char *dir = vec_get(std_include_path, i);`GoToNextLine ^(^

^)^: `         if (!strcmp(cur, fullpath(format("%s/%s", dir, filename))))`GoToNextLine ^(^

^)^: `             break;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     for (i++; i < vec_len(std_include_path); i++)`GoToNextLine ^(^

^)^: `         if (try_include(vec_get(std_include_path, i), filename, false))`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `   err:`GoToNextLine ^(^

^)^: `     errort(hash, "cannot find header file: %s", filename);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #pragma`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void parse_pragma_operand(Token *tok) {`GoToNextLine ^(^

^)^: `     char *s = tok->sval;`GoToNextLine ^(^

^)^: `     if (!strcmp(s, "once")) {`GoToNextLine ^(^

^)^: `         char *path = fullpath(tok->file->name);`GoToNextLine ^(^

^)^: `         map_put(once, path, (void *)1);`GoToNextLine ^(^

^)^: `     } else if (!strcmp(s, "enable_warning")) {`GoToNextLine ^(^

^)^: `         enable_warning = true;`GoToNextLine ^(^

^)^: `     } else if (!strcmp(s, "enable_warning")) {`GoToNextLine ^(^

^)^: `         enable_warning = false;`GoToNextLine ^(^

^)^: `         } else {`GoToNextLine ^(^

^)^: `         errort(tok, "unknown #pragma: %s", s);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #line`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static bool is_digit_sequence(char *p) {`GoToNextLine ^(^

^)^: `     for (; *p; p++)`GoToNextLine ^(^

^)^: `         if (!isdigit(*p))`GoToNextLine ^(^

^)^: `     return false;`GoToNextLine ^(^

^)^: `         return true;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TNUMBER || !is_digit_sequence(tok->sval))`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     int line = atoi(tok->sval);`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `     char *filename = NULL;`GoToNextLine ^(^

^)^: `         if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `         filename = tok->sval;`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     } else if (tok->kind != TNEWLINE) {`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     File *f = current_file();`GoToNextLine ^(^

^)^: `     f->line = line;`GoToNextLine ^(^

^)^: `     if (filename)`GoToNextLine ^(^

^)^: `         f->name = filename;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` // GNU CPP outputs "# linenum filename flags" to preserve original`GoToNextLine ^(^

^)^: ` // source file information. This function reads them. Flags are ignored.`GoToNextLine ^(^

^)^: ` static void parse_pragma_operand(Token *tok) {`GoToNextLine ^(^

^)^: `     if (!is_digit_sequence(tok->sval))`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     int line = atoi(tok->sval);`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         errort(tok, "identifier expected, but got %s", tok2s(tok));`GoToNextLine ^(^

^)^: `     char *filename = tok->sval;`GoToNextLine ^(^

^)^: `     do {`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `     } while (tok->kind != TNEWLINE);`GoToNextLine ^(^

^)^: `     File *file = current_file();`GoToNextLine ^(^

^)^: `     file->line = line;`GoToNextLine ^(^

^)^: `     file->name = filename;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * #-directive`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void read_else(Token *hash) {`GoToNextLine ^(^

^)^: `     Token *tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->kind == TEOF)`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `         if (tok->kind == TIDENT) {`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `         goto err;`GoToNextLine ^(^

^)^: `     char *s = tok->sval;`GoToNextLine ^(^

^)^: `     if (!strcmp(s, "define"))            read_define();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "import"))       read_include(hash, tok->file, true);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "include"))      read_include(hash, tok->file, false);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "include_next")) read_include_next(hash, tok->file);`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "if"))           read_if();`GoToNextLine ^(^

^)^: `     else if (!strcmp(s, "elif"))         read_elif(hash);`GoToNextLine ^(^

^)^: `     else goto err;`GoToNextLine ^(^

^)^: `         return;`GoToNextLine ^(^

^)^: `   err:`GoToNextLine ^(^

^)^: `     errort(hash, "unsupported preprocessor directive: %s", tok2s(tok));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Special macros`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static void make_token_pushback(Token *tmpl, int kind, char *sval) {`GoToNextLine ^(^

^)^: `     Token *tok = copy_token(tmpl);`GoToNextLine ^(^

^)^: `     r->kind = TMACRO_PARAM;`GoToNextLine ^(^

^)^: `     tok->sval = sval;`GoToNextLine ^(^

^)^: `     tok->slen = strlen(sval) + 1;`GoToNextLine ^(^

^)^: `     r->enc = ENC_NONE;`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     char buf[20];`GoToNextLine ^(^

^)^: `     strftime(buf, sizeof(buf), "%b %e %Y", &now);`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, strdup(buf));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     char buf[10];`GoToNextLine ^(^

^)^: `     strftime(buf, sizeof(buf), "%b %e %Y", &now);`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, strdup(buf));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     // [GNU] __TIMESTAMP__ is expanded to a string that describes the date`GoToNextLine ^(^

^)^: `     // and time of the last modification time of the current source file.`GoToNextLine ^(^

^)^: `     char buf[30];`GoToNextLine ^(^

^)^: `     strftime(buf, sizeof(buf), "%a %b %e %T %Y", localtime(&tmpl->file->mtime));`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, strdup(buf));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, tmpl->file->name);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, format("%d", tmpl->file->line));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     expect('(');`GoToNextLine ^(^

^)^: `     Token *operand = read_token();`GoToNextLine ^(^

^)^: `     if (operand->kind != TSTRING)`GoToNextLine ^(^

^)^: `         errort(operand, "_Pragma takes a string literal, but got %s", tok2s(operand));`GoToNextLine ^(^

^)^: `         expect(')');`GoToNextLine ^(^

^)^: `     parse_pragma_operand(operand);`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, "1");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TSTRING, get_base_file());`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     static int counter = 0;`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, format("%d", counter++));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void handle_date_macro(Token *tmpl) {`GoToNextLine ^(^

^)^: `     make_token_pushback(tmpl, TNUMBER, format("%d", stream_depth() - 1));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Constructors`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` void add_include_path(char *path) {`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, path);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void define_obj_macro(char *name, Token *value) {`GoToNextLine ^(^

^)^: `     map_put(macros, name, make_obj_macro(make_vector1(value)));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void define_special_macro(char *name, SpecialMacroHandler *fn) {`GoToNextLine ^(^

^)^: `     map_put(macros, name, make_special_macro(fn));`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: ` #define op(id, str)         map_put(keywords, str, (void *)id);`GoToNextLine ^(^

^)^: ` #define keyword(id, str, _) map_put(keywords, str, (void *)id);`GoToNextLine ^(^

^)^: ` #include "8cc.h"`GoToNextLine ^(^

^)^: ` #undef keyword`GoToNextLine ^(^

^)^: ` #undef op`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` static void read_define() {`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, BUILD_DIR "/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     vec_push(std_include_path, "/usr/local/lib/8cc/include");`GoToNextLine ^(^

^)^: `     define_special_macro("__DATE__", handle_date_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__TIME__", handle_time_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__FILE__", handle_file_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__LINE__", handle_line_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("_Pragma",  handle_pragma_macro);`GoToNextLine ^(^

^)^: `     // [GNU] Non-standard macros`GoToNextLine ^(^

^)^: `     define_special_macro("__BASE_FILE__", handle_base_file_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__COUNTER__", handle_counter_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__INCLUDE_LEVEL__", handle_include_level_macro);`GoToNextLine ^(^

^)^: `     define_special_macro("__TIMESTAMP__", handle_timestamp_macro);`GoToNextLine ^(^

^)^: `     read_from_string("#include <" BUILD_DIR "/include/8cc.h>");`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` void expect_newline() {`GoToNextLine ^(^

^)^: `     time_t timet = time(NULL);`GoToNextLine ^(^

^)^: `     localtime_r(&timet, &now);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` void expect_newline() {`GoToNextLine ^(^

^)^: `     setlocale(LC_ALL, "C");`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` /*`GoToNextLine ^(^

^)^: `  * Public intefaces`GoToNextLine ^(^

^)^: `  */`GoToNextLine ^(^

^)^: ` static Token *maybe_convert_keyword(Token *tok) {`GoToNextLine ^(^

^)^: `     if (tok->kind != TIDENT)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     int id = (intptr_t)map_get(keywords, tok->sval);`GoToNextLine ^(^

^)^: `     if (!id)`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: `     Token *r = copy_token(tok);`GoToNextLine ^(^

^)^: `     r->kind = TMACRO_PARAM;`GoToNextLine ^(^

^)^: `     r->id = id;`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` // Reads from a string as if the string is a content of input file.`GoToNextLine ^(^

^)^: ` // Convenient for evaluating small string snippet contaiing preprocessor macros.`GoToNextLine ^(^

^)^: ` void read_from_string(char *buf) {`GoToNextLine ^(^

^)^: `     stream_stash(make_file_string(buf));`GoToNextLine ^(^

^)^: `     Vector *toplevels = read_toplevels();`GoToNextLine ^(^

^)^: `     for (int i = 0; i < vec_len(toplevels); i++)`GoToNextLine ^(^

^)^: `         emit_toplevel(vec_get(toplevels, i));`GoToNextLine ^(^

^)^: `     token_buffer_unstash();`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` Token *peek_token() {`GoToNextLine ^(^

^)^: `     Token *r = read_token();`GoToNextLine ^(^

^)^: `                     vec_pop(r);`GoToNextLine ^(^

^)^: `     return r;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: ` Token *read_token() {`GoToNextLine ^(^

^)^: `     Token *tok;`GoToNextLine ^(^

^)^: `     for (;;) {`GoToNextLine ^(^

^)^: `             tok = lex();`GoToNextLine ^(^

^)^: `         if (tok->bol && is_keyword(tok, '#') && tok->hideset == NULL) {`GoToNextLine ^(^

^)^: `     unget_token(tok);`GoToNextLine ^(^

^)^: `             continue;`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^

^)^: `         assert(tok->kind < MIN_CPP_TOKEN);`GoToNextLine ^(^

^)^: `         return maybe_convert_keyword(tok);`GoToNextLine ^(^

^)^: ` }`GoToNextLine ^(^
